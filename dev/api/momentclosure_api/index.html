<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>MomentClosure.jl API · MomentClosure.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://augustinas1.github.io/MomentClosure.jl/api/momentclosure_api/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MomentClosure.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../../theory/moment_expansion_CME/">Moment Expansion (CME)</a></li><li><a class="tocitem" href="../../theory/moment_expansion_SDE/">Moment Expansion (SDE)</a></li><li><a class="tocitem" href="../../theory/moment_closure_approximations/">Moment Closure Approximations</a></li><li><a class="tocitem" href="../../theory/linear_mapping_approximation/">Linear Mapping Approximation</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../../tutorials/using_momentclosure/">Using MomentClosure</a></li><li><a class="tocitem" href="../../tutorials/using_momentclosure_SDE/">Moment Equations from SDEs</a></li><li><a class="tocitem" href="../../tutorials/common_issues/">Common Issues</a></li><li><a class="tocitem" href="../../tutorials/time-dependent_propensities/">Time-dependent Propensity Functions</a></li><li><a class="tocitem" href="../../tutorials/geometric_reactions+conditional_closures/">Geometrically Distributed Reaction Products and Conditional Closures</a></li><li><a class="tocitem" href="../../tutorials/P53_system_example/">P53 System Example</a></li><li><a class="tocitem" href="../../tutorials/derivative_matching_example/">Derivative Matching Example</a></li><li><a class="tocitem" href="../../tutorials/SIR_example/">SIR Model Example</a></li><li><a class="tocitem" href="../../tutorials/LMA_example/">LMA Example</a></li><li><a class="tocitem" href="../../tutorials/parameter_estimation_SDE/">Parameter Estimation of Diffusion Processes</a></li></ul></li><li><span class="tocitem">API</span><ul><li class="is-active"><a class="tocitem" href>MomentClosure.jl API</a><ul class="internal"><li><a class="tocitem" href="#Model-definition"><span>Model definition</span></a></li><li><a class="tocitem" href="#api-basic-network-properties"><span>Basic model properties</span></a></li><li><a class="tocitem" href="#Moment-Equations"><span>Moment Equations</span></a></li><li><a class="tocitem" href="#Moment-Closure"><span>Moment Closure</span></a></li><li><a class="tocitem" href="#visualisation_api"><span>Displaying Equations and Closures</span></a></li><li><a class="tocitem" href="#Linear-Mapping-Approximation"><span>Linear Mapping Approximation</span></a></li><li><a class="tocitem" href="#stochastic_simulation_utilities"><span>Stochastic Simulation Utilities</span></a></li></ul></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">API</a></li><li class="is-active"><a href>MomentClosure.jl API</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>MomentClosure.jl API</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/augustinas1/MomentClosure.jl/blob/main/docs/src/api/momentclosure_api.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="api"><a class="docs-heading-anchor" href="#api">MomentClosure.jl API</a><a id="api-1"></a><a class="docs-heading-anchor-permalink" href="#api" title="Permalink"></a></h1><h2 id="Model-definition"><a class="docs-heading-anchor" href="#Model-definition">Model definition</a><a id="Model-definition-1"></a><a class="docs-heading-anchor-permalink" href="#Model-definition" title="Permalink"></a></h2><p>MomentClosure is fully compatible with reaction network models defined using <a href="https://github.com/SciML/Catalyst.jl">Catalyst</a> and stored as a <a href="https://catalyst.sciml.ai/stable/api/catalyst_api/#ModelingToolkit.ReactionSystem"><code>ModelingToolkit.ReactionSystem</code></a>. Note that previously we had implemented our own <code>ReactionSystemMod</code>, that allowed us to consider systems containing reactions which products are independent geometrically distributed random variables. However, this is now deprecated as Catalyst has added support for such parameteric stoichiometries offering a much more complete and efficient feature set.</p><h2 id="api-basic-network-properties"><a class="docs-heading-anchor" href="#api-basic-network-properties">Basic model properties</a><a id="api-basic-network-properties-1"></a><a class="docs-heading-anchor-permalink" href="#api-basic-network-properties" title="Permalink"></a></h2><p>Moreover, we include a couple of tiny extensions to the Catalyst API:</p><article class="docstring"><header><a class="docstring-binding" id="MomentClosure.propensities" href="#MomentClosure.propensities"><code>MomentClosure.propensities</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">propensities(rn::Union{ReactionSystem, ReactionSystemMod}; combinatoric_ratelaw=true)</code></pre><p>Return a vector of propensity functions of all reactions in the given <a href="https://catalyst.sciml.ai/stable/api/catalyst_api/#ModelingToolkit.ReactionSystem"><code>ReactionSystem</code></a>.</p><p>Notes:</p><ul><li><code>combinatoric_ratelaw=true</code> uses binomials in calculating the propensity functions of a <code>ReactionSystem</code>, see the notes for <a href="https://mtk.sciml.ai/stable/systems/ReactionSystem/#ModelingToolkit.jumpratelaw"><code>ModelingToolkit.jumpratelaw</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/augustinas1/MomentClosure.jl/blob/0e89f6f86f6c9ebf5b2a5529136032511e0514e0/src/reaction_systems.jl#LL1-L10">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MomentClosure.get_stoichiometry" href="#MomentClosure.get_stoichiometry"><code>MomentClosure.get_stoichiometry</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_stoichiometry(rn::ReactionSystem, smap::AbstractDict)</code></pre><p>Return the net stoichiometry matrix using the specified mapping of species to their indices.</p><p>Notes:</p><ul><li>This is a modification of <a href="https://catalyst.sciml.ai/stable/api/catalyst_api/#Catalyst.netstoichmat"><code>Catalyst.netstoichmat</code></a>  that is used internally to deal with reactions involving symbolic stoichiometry coefficients.</li><li>The function also allows custom <code>smap</code>, so it is not limited to the default  <a href="https://catalyst.sciml.ai/stable/api/catalyst_api/#Catalyst.speciesmap"><code>Catalyst.speciesmap</code></a> ordering.</li><li>TODO: remove once <a href="https://github.com/SciML/Catalyst.jl/issues/489">this Catalyst issue</a> is resolved.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/augustinas1/MomentClosure.jl/blob/0e89f6f86f6c9ebf5b2a5529136032511e0514e0/src/reaction_systems.jl#LL15-L26">source</a></section></article><h2 id="Moment-Equations"><a class="docs-heading-anchor" href="#Moment-Equations">Moment Equations</a><a id="Moment-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Moment-Equations" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MomentClosure.generate_raw_moment_eqs" href="#MomentClosure.generate_raw_moment_eqs"><code>MomentClosure.generate_raw_moment_eqs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generate_raw_moment_eqs(rn::ReactionSystem, m_order::Int;
                        langevin::Bool=false, combinatoric_ratelaw::Bool=true, smap=speciesmap(rn))</code></pre><p>Given a <a href="https://catalyst.sciml.ai/stable/api/catalyst_api/#ModelingToolkit.ReactionSystem"><code>ReactionSystem</code></a> return the <a href="#MomentClosure.RawMomentEquations"><code>RawMomentEquations</code></a> of the system generated up to <code>m_order</code>.</p><p>Notes:</p><ul><li>The expansion order <span>$q$</span>, denoted by <code>q_order</code> throughout the docs, is automatically determined from the given polynomial form of the propensity functions, see the <a href="../../tutorials/using_momentclosure/#main_tutorial">tutorial</a> and the <a href="../../theory/moment_expansion_CME/#raw_moment_eqs">theory section</a> for more details on how <code>q_order</code> is obtained.</li><li>if <code>langevin=true</code>, instead of the Chemical Master Equation the Chemical Langevin Equation (diffusion approximation) is considered, and the moment equations are  constructed from the corresponding SDE formulation.</li><li><code>combinatoric_ratelaw=true</code> uses binomials in calculating the propensity functions of a <code>ReactionSystem</code>, see the notes for <a href="https://mtk.sciml.ai/stable/systems/ReactionSystem/#ModelingToolkit.jumpratelaw"><code>ModelingToolkit.jumpratelaw</code></a>. <em>Note</em> that this field is irrelevant using <code>ReactionSystemMod</code> as then the propensities are defined directly by the user.</li><li><code>smap</code> sets the variable ordering in the moment equations (which index corresponds to which species in the reaction network). By default, this is consistent with the internal system ordering accessible with <a href="https://catalyst.sciml.ai/stable/api/catalyst_api/#Catalyst.speciesmap"><code>Catalyst.speciesmap</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/augustinas1/MomentClosure.jl/blob/0e89f6f86f6c9ebf5b2a5529136032511e0514e0/src/raw_moment_equations.jl#LL1-L24">source</a></section><section><div><pre><code class="nohighlight hljs">generate_raw_moment_eqs(sys::SDESystem, m_order::Int)</code></pre><p>Given an <a href="https://mtk.sciml.ai/stable/systems/SDESystem/#ModelingToolkit.SDESystem"><code>SDESystem</code></a>,  return the <a href="#MomentClosure.RawMomentEquations"><code>RawMomentEquations</code></a> of the system generated up to <code>m_order</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/augustinas1/MomentClosure.jl/blob/0e89f6f86f6c9ebf5b2a5529136032511e0514e0/src/raw_moment_equations_SDE.jl#LL57-L62">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MomentClosure.RawMomentEquations" href="#MomentClosure.RawMomentEquations"><code>MomentClosure.RawMomentEquations</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct RawMomentEquations &lt;: MomentClosure.MomentEquations</code></pre><p>Raw moment equations generated for the given system plus a number of helper parameters (used internally).</p><p><strong>Fields</strong></p><ul><li><p><code>odes</code></p><p><a href="https://mtk.sciml.ai/stable/systems/ODESystem/"><code>ModelingToolkit.ODESystem</code></a> consisting of the time-evolution equations of raw moments.</p></li><li><p><code>μ</code></p><p>Symbolic variables defining the raw moments.</p></li><li><p><code>N</code></p><p>Number of species within the system.</p></li><li><p><code>m_order</code></p><p>Order of moment equations.</p></li><li><p><code>q_order</code></p><p>Expansion order.</p></li><li><p><code>iter_all</code></p><p>Vector of all index combinations up to <code>q_order</code>.</p></li><li><p><code>iter_m</code></p><p>Vector of all index combinations up to <code>m_order</code>.</p></li><li><p><code>iter_q</code></p><p>Vector of all index combinations of order greater than <code>m_order</code> up to <code>q_order</code>.</p></li><li><p><code>iter_1</code></p><p>Vector of index combinations of order 1.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/augustinas1/MomentClosure.jl/blob/0e89f6f86f6c9ebf5b2a5529136032511e0514e0/src/moment_equations.jl#LL5">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MomentClosure.generate_central_moment_eqs" href="#MomentClosure.generate_central_moment_eqs"><code>MomentClosure.generate_central_moment_eqs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">generate_central_moment_eqs(rn::ReactionSystem, m_order::Int, q_order::Int=0;
                            langevin::Bool=false, combinatoric_ratelaw::Bool=true, smap=speciesmap(rn))</code></pre><p>Given a <a href="https://catalyst.sciml.ai/stable/api/catalyst_api/#ModelingToolkit.ReactionSystem"><code>ReactionSystem</code></a> return the <a href="#MomentClosure.CentralMomentEquations"><code>CentralMomentEquations</code></a> of the system generated up to <code>m_order</code>.</p><p>Notes:</p><ul><li>if <code>q_order</code> is not specified by the user, it is assumed that the reaction network contains <em>only</em> polynomial propensity functions and hence <code>q_order</code> is determined automatically as in <a href="#MomentClosure.generate_raw_moment_eqs"><code>generate_raw_moment_eqs</code></a>. However, <code>q_order</code> must be specified if non-polynomial propensities are included. Note that the expansion order <span>$q$</span> denotes the highest order of central moments which will be included in the ODEs <a href="../../theory/moment_expansion_CME/#central_moment_eqs">(due to the Taylor expansion of propensity functions)</a>.</li><li>if <code>langevin=true</code>, instead of the Chemical Master Equation the Chemical Langevin Equation (diffusion approximation) is considered, and the moment equations are  constructed from the corresponding SDE formulation.</li><li><code>combinatoric_ratelaw=true</code> uses binomials in calculating the propensity functions of a <code>ReactionSystem</code>, see the notes for <a href="https://mtk.sciml.ai/stable/systems/ReactionSystem/#ModelingToolkit.jumpratelaw"><code>ModelingToolkit.jumpratelaw</code></a>. <em>Note</em> that this field is irrelevant using <code>ReactionSystemMod</code> as then the propensities are defined directly by the user.</li><li><code>smap</code> sets the variable ordering in the moment equations (which index corresponds to which species in the reaction network). By default, this is consistent with the internal system ordering accessible with <a href="https://catalyst.sciml.ai/stable/api/catalyst_api/#Catalyst.speciesmap"><code>Catalyst.speciesmap</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/augustinas1/MomentClosure.jl/blob/0e89f6f86f6c9ebf5b2a5529136032511e0514e0/src/central_moment_equations.jl#LL18-L43">source</a></section><section><div><pre><code class="nohighlight hljs">generate_central_moment_eqs(sys::SDESystem, m_order::Int, q_order::Int=0)</code></pre><p>Given an <a href="https://mtk.sciml.ai/stable/systems/SDESystem/#ModelingToolkit.SDESystem"><code>SDESystem</code></a>,  return the <a href="#MomentClosure.CentralMomentEquations"><code>CentralMomentEquations</code></a> of the system generated up to <code>m_order</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/augustinas1/MomentClosure.jl/blob/0e89f6f86f6c9ebf5b2a5529136032511e0514e0/src/central_moment_equations_SDE.jl#LL102-L107">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MomentClosure.CentralMomentEquations" href="#MomentClosure.CentralMomentEquations"><code>MomentClosure.CentralMomentEquations</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct CentralMomentEquations &lt;: MomentClosure.MomentEquations</code></pre><p>Central moment equations generated for the given system plus a number of helper parameters (used internally).</p><p><strong>Fields</strong></p><ul><li><p><code>odes</code></p><p><a href="https://mtk.sciml.ai/stable/systems/ODESystem/"><code>ModelingToolkit.ODESystem</code></a> consisting of the time-evolution equations of central moments.</p></li><li><p><code>μ</code></p><p>Symbolic variables defining the means.</p></li><li><p><code>M</code></p><p>Symbolic variables defining the central moments.</p></li><li><p><code>N</code></p><p>Number of species within the system.</p></li><li><p><code>m_order</code></p><p>Order of moment equations.</p></li><li><p><code>q_order</code></p><p>Expansion order.</p></li><li><p><code>iter_all</code></p><p>Vector of all index combinations up to <code>q_order</code>.</p></li><li><p><code>iter_m</code></p><p>Vector of all index combinations up to <code>m_order</code>.</p></li><li><p><code>iter_q</code></p><p>Vector of all index combinations of order greater than <code>m_order</code> up to <code>q_order</code>.</p></li><li><p><code>iter_1</code></p><p>Vector of index combinations of order 1.</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/augustinas1/MomentClosure.jl/blob/0e89f6f86f6c9ebf5b2a5529136032511e0514e0/src/moment_equations.jl#LL37">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MomentClosure.bernoulli_moment_eqs" href="#MomentClosure.bernoulli_moment_eqs"><code>MomentClosure.bernoulli_moment_eqs</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">bernoulli_moment_eqs(sys::MomentEquations, binary_vars::Array{Int,1})</code></pre><p>Given <code>MomentEquations</code> and an array of indices specifying the species which molecule numbers are binary variables (either 0 or 1), apply identities of Bernoulli variables to remove the redundant ODEs and return the <em>cleaned up</em> <code>MomentEquations</code>. See <a href="../../tutorials/geometric_reactions+conditional_closures/#geometric-and-conditional">here</a> for example usage.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/augustinas1/MomentClosure.jl/blob/0e89f6f86f6c9ebf5b2a5529136032511e0514e0/src/bernoulli.jl#LL70-L77">source</a></section></article><h2 id="Moment-Closure"><a class="docs-heading-anchor" href="#Moment-Closure">Moment Closure</a><a id="Moment-Closure-1"></a><a class="docs-heading-anchor-permalink" href="#Moment-Closure" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MomentClosure.moment_closure" href="#MomentClosure.moment_closure"><code>MomentClosure.moment_closure</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">moment_closure(sys::MomentEquations, closure::String, binary_vars::Array{Int,1}=Int[])</code></pre><p>Given <code>MomentEquations</code>, apply the specified moment closure approximation and return the <a href="#MomentClosure.ClosedMomentEquations"><code>ClosedMomentEquations</code></a>.</p><p>The supported <code>closure</code> options are:</p><ul><li><a href="../../theory/moment_closure_approximations/#zero_closure"><code>&quot;zero&quot;</code></a></li><li><a href="../../theory/moment_closure_approximations/#normal_closure"><code>&quot;normal&quot;</code></a></li><li><a href="../../theory/moment_closure_approximations/#log-normal_closure"><code>&quot;log-normal&quot;</code></a></li><li><a href="../../theory/moment_closure_approximations/#poisson_closure"><code>&quot;poisson&quot;</code></a></li><li><a href="../../theory/moment_closure_approximations/#gamma_closure"><code>&quot;gamma&quot;</code></a></li><li><a href="../../theory/moment_closure_approximations/#derivative_matching"><code>&quot;derivative matching&quot;</code></a></li><li><a href="../../theory/moment_closure_approximations/#conditional_gaussian_closure"><code>&quot;conditional gaussian&quot;</code></a></li><li><a href="../../theory/moment_closure_approximations/#conditional_derivative_matching"><code>&quot;conditional derivative matching&quot;</code></a></li></ul><p><strong>Notes</strong></p><ul><li><code>binary_vars</code> <em>must</em> be specified for conditional closures as an array of indices of all species (as in <a href="https://catalyst.sciml.ai/stable/api/catalyst_api/#Catalyst.speciesmap"><code>Catalyst.speciesmap</code></a>)  which molecule number is a Bernoulli variable. Although not necessary for other closures, specifying <code>binary_vars</code> is recommended as the properties of Bernoulli variables will be used to remove the redundant moment equations and simplify the expressions, which can significantly improve numerical stability.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/augustinas1/MomentClosure.jl/blob/0e89f6f86f6c9ebf5b2a5529136032511e0514e0/src/closure_methods/closure.jl#LL30-L53">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MomentClosure.ClosedMomentEquations" href="#MomentClosure.ClosedMomentEquations"><code>MomentClosure.ClosedMomentEquations</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia hljs">struct ClosedMomentEquations &lt;: MomentClosure.MomentEquations</code></pre><p>Closed moment equations and the corresponding closure functions.</p><p><strong>Fields</strong></p><ul><li><p><code>odes</code></p><p><a href="https://mtk.sciml.ai/stable/systems/ODESystem/"><code>ModelingToolkit.ODESystem</code></a> consisting of the time-evolution equations of <em>closed</em> moments.</p></li><li><p><code>closure</code></p><p>Dictionary of moment closure functions for each higher order moment.</p></li><li><p><code>open_eqs</code></p><p>Original raw or central moment equations (before closure was applied).</p></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/augustinas1/MomentClosure.jl/blob/0e89f6f86f6c9ebf5b2a5529136032511e0514e0/src/moment_equations.jl#LL71">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MomentClosure.deterministic_IC" href="#MomentClosure.deterministic_IC"><code>MomentClosure.deterministic_IC</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">deterministic_IC(u₀::Array{T, 1}, eqs::MomentEquations) where T&lt;:Real</code></pre><p>Given an array of initial molecule numbers and the corresponding moment equations, return a mapping of each moment to its initial value under deterministic initial conditions.</p><p><strong>Notes</strong></p><ul><li>The means are set to initial molecule numbers (as they take the values specified in <code>u₀</code> with probability one). The higher order raw moments are products of the corresponding powers of the means whereas the higher order central moments are simply zero.</li><li>The ordering of <code>u₀</code> elements must be consistent with the ordering of species in the corresponding reaction system (can be checked with the  <a href="https://catalyst.sciml.ai/stable/api/catalyst_api/#Catalyst.speciesmap"><code>Catalyst.speciesmap</code></a>  function).</li><li>As higher-order moment functions under log-normal, gamma, derivative matching and the conditional closures involve moments raised to negative powers, setting initial molecule numbers of certain species to <em>zeros</em> will result in NaN errors when solving the ODEs (the specifics depend on the system at hand).</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/augustinas1/MomentClosure.jl/blob/0e89f6f86f6c9ebf5b2a5529136032511e0514e0/src/utils.jl#LL240-L258">source</a></section></article><h2 id="visualisation_api"><a class="docs-heading-anchor" href="#visualisation_api">Displaying Equations and Closures</a><a id="visualisation_api-1"></a><a class="docs-heading-anchor-permalink" href="#visualisation_api" title="Permalink"></a></h2><p>The generated moment equations can be converted into LaTeX expressions using <a href="https://github.com/korsbo/Latexify.jl">Latexify</a> as:</p><pre><code class="language-julia hljs">using Latexify
latexify(moment_eqs)</code></pre><p>A <a href="https://mtk.sciml.ai/stable/systems/ODESystem/"><code>ModelingToolkit.ODESystem</code></a> (saved as <code>moment_eqs.odes</code>) can also be passed to <code>latexify</code> function directly but the output will be different as we apply additional formatting to the symbolic expressions.</p><p>Given <a href="#MomentClosure.ClosedMomentEquations"><code>ClosedMomentEquations</code></a>, the closure functions can be visualised in the same way by adding a <code>:closure</code> argument:</p><pre><code class="language-julia hljs">latexify(moment_eqs, :closure)</code></pre><p>Note that this will print out only those higher order moments which are found in the given moment equations. It is possible to print the closure functions of <em>all</em> higher order moments using <code>print_all=true</code> argument:</p><pre><code class="language-julia hljs">latexify(moment_eqs, :closure, print_all=true)</code></pre><h2 id="Linear-Mapping-Approximation"><a class="docs-heading-anchor" href="#Linear-Mapping-Approximation">Linear Mapping Approximation</a><a id="Linear-Mapping-Approximation-1"></a><a class="docs-heading-anchor-permalink" href="#Linear-Mapping-Approximation" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="MomentClosure.linear_mapping_approximation" href="#MomentClosure.linear_mapping_approximation"><code>MomentClosure.linear_mapping_approximation</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">  linear_mapping_approximation(rn_nonlinear::T, rn_linear::T, binary_vars::Array{Int,1}=Int[], m_order::Int=0;
                               combinatoric_ratelaw = true) where T &lt;: ReactionSystem</code></pre><p>Given a <em>nonlinear</em> <a href="https://catalyst.sciml.ai/stable/api/catalyst_api/#ModelingToolkit.ReactionSystem"><code>ReactionSystem</code></a> and an equivalent <em>linear</em> <code>ReactionSystem</code>, perform the Linear Mapping Approximation (LMA) and return the corresponding linear <a href="#MomentClosure.RawMomentEquations"><code>RawMomentEquations</code></a> of the system as well as a Dictionary of reaction parameter substitutions obtained using LMA that are used to generate the moment equations. See the <a href="../../theory/linear_mapping_approximation/#linear_mapping_approximation">LMA theory section</a> for more details.</p><p>Notes:</p><ul><li><code>rn_nonlinear</code> and <code>rn_linear</code> must be <em>identical</em> in layout in order to be interpreted correctly, and the nonlinear reactions contained in <code>rn_nonlinear</code> must all be linearised in <code>rn_linear</code> with rate coefficients updated accordingly. Although this requires a lot of manual input, automating the linearisation further is difficult due to arbitrary choices that may be mane in constructing the reaction networks.</li><li><code>binary_vars</code> <em>must</em> be specified for conditional closures as an array of indices of all species (as in <a href="https://catalyst.sciml.ai/stable/api/catalyst_api/#Catalyst.speciesmap"><code>Catalyst.speciesmap</code></a>)  which molecule number is a Bernoulli variable. Note that <code>rn_nonlinear</code> and <code>rn_linear</code> may internally order the species differently: <code>binary_vars</code> must be consistent with the ordering in the <em>nonlinear</em> network.</li><li>By default the moment equations will be generated up to the order determined by the degree of nonlinearity of the nonlinear system&#39;s reactions. However, if higher order moment information is required, the optional <code>m_order</code> argument may be provided to increase the expansion order manually.</li><li><code>combinatoric_ratelaw=true</code> uses binomials in calculating the propensity functions of a <code>ReactionSystem</code>, see the notes for <a href="https://mtk.sciml.ai/stable/systems/ReactionSystem/#ModelingToolkit.jumpratelaw"><code>ModelingToolkit.jumpratelaw</code></a>.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/augustinas1/MomentClosure.jl/blob/0e89f6f86f6c9ebf5b2a5529136032511e0514e0/src/closure_methods/linear_mapping_approximation.jl#LL1-L27">source</a></section></article><h2 id="stochastic_simulation_utilities"><a class="docs-heading-anchor" href="#stochastic_simulation_utilities">Stochastic Simulation Utilities</a><a id="stochastic_simulation_utilities-1"></a><a class="docs-heading-anchor-permalink" href="#stochastic_simulation_utilities" title="Permalink"></a></h2><p>We provide provides functions for higher-order moment extraction from SSA and FSP data:</p><article class="docstring"><header><a class="docstring-binding" id="MomentClosure.get_raw_moments" href="#MomentClosure.get_raw_moments"><code>MomentClosure.get_raw_moments</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_raw_moments(sol::EnsembleSolution, order::Int; naive::Bool=true, b::Int=2)</code></pre><p>Given an <code>EnsembleSolution</code> of <a href="https://diffeq.sciml.ai/stable/features/ensemble/#Performing-an-Ensemble-Simulation">DifferentialEquations ensemble simulation</a>, return a Dictionary of raw moments computed up to the specified <code>order</code> at each time step.</p><p><strong>Notes</strong></p><ul><li>For example, the dictionary key <code>(2,0,1)</code> maps to an array containing the values of the raw moment <span>$μ_{201}$</span> at each time step.</li><li>It is assumed that the time steps are all at the same time point for all trajectories (i.e., fixed <code>dt</code> used by the integrator or values were saved using <code>saveat</code>, as discussed <a href="https://diffeq.sciml.ai/stable/features/ensemble/#Time-steps-vs-time-points">here</a>).</li><li>Moments are computed using <a href="https://github.com/iitis/Cumulants.jl">Cumulants.jl</a> internally. The naive algorithm of moment tensor calculations (<code>naive=true</code>) is usually faster for small systems but the <a href="https://arxiv.org/pdf/1701.05420.pdf">proposed novel algorithm</a> (<code>naive=false</code>) <em>should</em> be more efficient in case of many marginal variables. The <a href="https://github.com/iitis/Cumulants.jl#block-size">block size</a> <code>b</code> can also be specified for the novel algorithm and may have a significant effect on its performance.</li><li>Only useful if higher order moments are needed: DifferentialEquations has a number of far more efficient and flexible ensemble statistics functions for means, variances and correlations, see <a href="https://diffeq.sciml.ai/stable/features/ensemble/#Analyzing-an-Ensemble-Experiment">this tutorial</a> for more details.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/augustinas1/MomentClosure.jl/blob/0e89f6f86f6c9ebf5b2a5529136032511e0514e0/src/utils.jl#LL1-L25">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MomentClosure.get_central_moments" href="#MomentClosure.get_central_moments"><code>MomentClosure.get_central_moments</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_central_moments(sol::EnsembleSolution, order::Int; naive::Bool=true, b::Int=2)</code></pre><p>Given an <code>EnsembleSolution</code> of <a href="https://diffeq.sciml.ai/stable/features/ensemble/#Performing-an-Ensemble-Simulation">DifferentialEquations ensemble simulation</a>, return a Dictionary of central moment estimates computed up to the specified <code>order</code> at each time step. See the notes of <a href="#MomentClosure.get_raw_moments"><code>get_raw_moments</code></a> function for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/augustinas1/MomentClosure.jl/blob/0e89f6f86f6c9ebf5b2a5529136032511e0514e0/src/utils.jl#LL66-L73">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MomentClosure.get_cumulants" href="#MomentClosure.get_cumulants"><code>MomentClosure.get_cumulants</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_cumulants(sol::EnsembleSolution, order::Int; naive::Bool=true, b::Int=2)</code></pre><p>Given an <code>EnsembleSolution</code> of <a href="https://diffeq.sciml.ai/stable/features/ensemble/#Performing-an-Ensemble-Simulation">DifferentialEquations ensemble simulation</a>, return a Dictionary of cumulant estimates computed up to the specified <code>order</code> at each time step. See the notes of <a href="#MomentClosure.get_raw_moments"><code>get_raw_moments</code></a> function for more information.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/augustinas1/MomentClosure.jl/blob/0e89f6f86f6c9ebf5b2a5529136032511e0514e0/src/utils.jl#LL116-L123">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="MomentClosure.get_moments_FSP" href="#MomentClosure.get_moments_FSP"><code>MomentClosure.get_moments_FSP</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia hljs">get_moments_FSP(sol::ODESolution, order::Int, moment_type::String)</code></pre><p>Given an <code>ODESolution</code> obtained using <a href="https://github.com/kaandocal/FiniteStateProjection.jl">FiniteStateProjection.jl</a>, return a Dictionary of moments computed up to the specified <code>order</code> at each time step. Here, <code>moment_type</code> specifies the type of moments to be computed: available options are <code>raw</code>, <code>central</code> or <code>cumulant</code>.</p><p><strong>Notes</strong></p><ul><li>The <code>ODESolution</code> represents the time-evolution of the probability density function that is the solution of the Chemical Master Equation approximated using Finite State Projection algorithms. See the documentation of <a href="https://github.com/kaandocal/FiniteStateProjection.jl">FiniteStateProjection.jl</a> for more information.</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/augustinas1/MomentClosure.jl/blob/0e89f6f86f6c9ebf5b2a5529136032511e0514e0/src/utils.jl#LL179-L192">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../tutorials/parameter_estimation_SDE/">« Parameter Estimation of Diffusion Processes</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Tuesday 5 July 2022 15:11">Tuesday 5 July 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
