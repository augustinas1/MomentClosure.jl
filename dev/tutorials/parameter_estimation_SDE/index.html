<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Parameter Estimation of Diffusion Processes · MomentClosure.jl</title><meta name="title" content="Parameter Estimation of Diffusion Processes · MomentClosure.jl"/><meta property="og:title" content="Parameter Estimation of Diffusion Processes · MomentClosure.jl"/><meta property="twitter:title" content="Parameter Estimation of Diffusion Processes · MomentClosure.jl"/><meta name="description" content="Documentation for MomentClosure.jl."/><meta property="og:description" content="Documentation for MomentClosure.jl."/><meta property="twitter:description" content="Documentation for MomentClosure.jl."/><meta property="og:url" content="https://augustinas1.github.io/MomentClosure.jl/tutorials/parameter_estimation_SDE/"/><meta property="twitter:url" content="https://augustinas1.github.io/MomentClosure.jl/tutorials/parameter_estimation_SDE/"/><link rel="canonical" href="https://augustinas1.github.io/MomentClosure.jl/tutorials/parameter_estimation_SDE/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MomentClosure.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../../theory/moment_expansion_CME/">Moment Expansion (CME)</a></li><li><a class="tocitem" href="../../theory/moment_expansion_SDE/">Moment Expansion (SDE)</a></li><li><a class="tocitem" href="../../theory/moment_closure_approximations/">Moment Closure Approximations</a></li><li><a class="tocitem" href="../../theory/linear_mapping_approximation/">Linear Mapping Approximation</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../using_momentclosure/">Using MomentClosure</a></li><li><a class="tocitem" href="../using_momentclosure_SDE/">Moment Equations from SDEs</a></li><li><a class="tocitem" href="../common_issues/">Common Issues</a></li><li><a class="tocitem" href="../time-dependent_propensities/">Time-dependent Propensity Functions</a></li><li><a class="tocitem" href="../geometric_reactions+conditional_closures/">Geometrically Distributed Reaction Products and Conditional Closures</a></li><li><a class="tocitem" href="../P53_system_example/">P53 System Example</a></li><li><a class="tocitem" href="../derivative_matching_example/">Derivative Matching Example</a></li><li><a class="tocitem" href="../SIR_example/">SIR Model Example</a></li><li><a class="tocitem" href="../LMA_example/">LMA Example</a></li><li class="is-active"><a class="tocitem" href>Parameter Estimation of Diffusion Processes</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../api/momentclosure_api/">MomentClosure.jl API</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Parameter Estimation of Diffusion Processes</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Parameter Estimation of Diffusion Processes</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/augustinas1/MomentClosure.jl/blob/main/docs/src/tutorials/parameter_estimation_SDE.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="parameter_estimation_SDE"><a class="docs-heading-anchor" href="#parameter_estimation_SDE">Parameter Estimation of Diffusion Processes</a><a id="parameter_estimation_SDE-1"></a><a class="docs-heading-anchor-permalink" href="#parameter_estimation_SDE" title="Permalink"></a></h1><p>In this tutorial, we look at the problem of model parameter identification of a diffusion process given timeseries data of its moments. Namely, we use moment closure approximations (MAs) to make the optimisation process more efficient by reducing the model evaluation time. All credit for this tutorial goes to Flemming Holtorf!</p><p>We consider a noisy variation of the <a href="https://en.wikipedia.org/wiki/Lotka%E2%80%93Volterra_equations">Lotka-Volterra model</a>, describing the interaction between a predator and prey species:</p><p class="math-container">\[\begin{align*}
    \begin{bmatrix} dx \\ dy \end{bmatrix} = 
    \begin{bmatrix} \gamma_1 x(t) - \gamma_2  x(t)  y(t)  \\ \gamma_4 x(t)  y(t) - \gamma_3 y(t) - \frac{1}{2} y(t) \end{bmatrix} \, dt 
    + \begin{bmatrix}  \gamma_5 x(t) \\ 0 \end{bmatrix} \, dW_t
\end{align*}\]</p><p>We can define this system of SDEs using ModelingToolkit as follows:</p><pre><code class="language-julia hljs">using ModelingToolkit

@variables t, x(t), y(t)
@parameters γ1, γ2, γ3, γ4, γ5
γ = [γ1, γ2, γ3, γ4, γ5]  
drift_eqs = [Differential(t)(x) ~ γ[1] * x - γ[2] * x * y ;
             Differential(t)(y) ~ γ[4] * x * y - γ[3] * y - y*0.5]
diff_eqs = [γ[5]*x; 0]
LV = SDESystem(drift_eqs, diff_eqs, t, [x,y], γ, name = :LV)</code></pre><p>Next, we generate some data used for the parameter estimation. Namely, we collect timeseries data of means and variances of both species:</p><pre><code class="language-julia hljs">using DifferentialEquations, DifferentialEquations.EnsembleAnalysis

N_samples = 1000
Tf = 10
t_data = 0:0.2:Tf
p_true = [γ[1] =&gt; 1, γ[2] =&gt; 2, γ[3] =&gt; 1, γ[4] =&gt; 2, γ[5] =&gt; 0.1]
u0 = [1.0, 0.25]
LV_data = solve(EnsembleProblem(SDEProblem(LV, u0, (0.0, Tf), p_true)), saveat = t_data, trajectories = N_samples)
means, vars = timeseries_steps_meanvar(LV_data)</code></pre><p>Now we are ready to test if we can estimate the model parameters <span>$\gamma_1, \dotsc, \gamma_5$</span> solely from the data collected above. We first approach this parameter identification problem using the asymptotically exact approach of estimating the means and variances of the process with ensemble averages. Accordingly, we construct the following loss function:</p><pre><code class="language-julia hljs">using LinearAlgebra

LV_sde = SDEProblem(LV, u0, (0.0, Tf), zeros(5))
function obj(p)
    prob = remake(LV_sde, p = p)
    sol = solve(EnsembleProblem(prob), saveat = t_data, trajectories = 1000)
    sol_mean, sol_vars = timeseries_steps_meanvar(sol)
    obj = sum(norm(sol_mean[i] - means[i])^2 for i in 1:length(t_data))
    obj += 1e4*sum(norm(sol_vars[i] - vars[i])^2 for i in 1:length(t_data))
    return obj
end</code></pre><p>We can use this loss function with any suitable optimisation routine to identify a reasonable choice of the model parameters. For example, we can use a very simple derivative-free optimizer (Nelder-Mead method) implemented in the <a href="https://github.com/JuliaNLSolvers/Optim.jl">Optim.jl</a> package. Since a single evaluation of the objective function requires sampling and hence is relatively expensive, we impose the constraint that the optimiser cannot run more than 2 minutes:</p><pre><code class="language-julia hljs">using Optim

pmap = Dict(i =&gt; findfirst(isequal(γ[i]), parameters(LV)) for i in 1:5)
p_init = Dict(γ[1] =&gt; 1.3, γ[2] =&gt; 1.5, γ[3] =&gt; 1.4, γ[4] =&gt; 2.2, γ[5] =&gt; 0.1)
p = [p_init[γ[pmap[i]]] for i in 1:5]
opt_sampling = Optim.optimize(obj, p, Optim.Options(time_limit = 120))</code></pre><pre><code class="language-julia hljs">* Status: failure (exceeded time limit of 120.0)

 * Candidate solution
    Final objective value:     3.550929e+00

 * Found with
    Algorithm:     Nelder-Mead

 * Convergence measures
    √(Σ(yᵢ-ȳ)²)/n ≰ 1.0e-08

 * Work counters
    Seconds run:   121  (vs limit 120)
    Iterations:    139
    f(x) calls:    337</code></pre><p>We can visualise the moment statistics obtained using the estimated parameters and compare to the true data:</p><pre><code class="language-julia hljs">using Plots

t_detail = collect(0:0.01:Tf) 
opt_sol = solve(EnsembleProblem(SDEProblem(LV, u0, (0.0, Tf), opt_sampling.minimizer)), saveat = t_detail, trajectories = 1000)
opt_means, opt_vars = timeseries_steps_meanvar(opt_sol)

mean_comp = scatter(t_data, [m[1] for m in means], color = :blue,
                    xlabel = &quot;time&quot;, ylabel = &quot;population size&quot;, 
                    grid = false, title = &quot;means&quot;, label = &quot;⟨x⟩ data&quot;)
scatter!(mean_comp, t_data, [m[2] for m in means], color = :red, label = &quot;⟨y⟩ data&quot;)
plot!(mean_comp, t_detail, [m[1] for m in opt_means], linewidth = 2, color = :blue, label = &quot;⟨x⟩ SDE model&quot;)
plot!(mean_comp, t_detail, [m[2] for m in opt_means], linewidth = 2, color = :red, label = &quot;⟨y⟩ SDE model&quot;)

var_comp = scatter(t_data, [v[1] for v in vars], color = :blue, grid = false,
                   xlabel = &quot;time&quot;, title = &quot;variances&quot;, label = &quot;σ²(x) data&quot;, legend = :topleft)
scatter!(var_comp, t_data, [v[2] for v in vars], color = :red, label = &quot;σ²(y) data&quot;)
plot!(var_comp, t_detail, [v[1] for v in opt_vars], color = :blue, label = &quot;σ²(x) SDE model&quot;)
plot!(var_comp, t_detail, [v[2] for v in opt_vars], color = :red, label = &quot;σ²(y) SDE model&quot;)

plot(mean_comp, var_comp, size = (1200.0, 400.0))</code></pre><p><img src="../../assets/LV_SDE_fig1.svg" alt="LV SDE fig1"/></p><p>We observe that the identified parameters match the data reasonably well. However, one may suspect that the optimiser is converging to a local minimum as the fit is not perfect.</p><p>Now we approach the same model identification problem via MAs in the hope of cutting down model evaluation cost, allowing us to identify better parameters in the same (or less) time. To that end, we construct an approximation of the moment dynamics of the process assuming that the distribution of the system state is approximately log-normal over the simulation horizon (using <a href="../../theory/moment_closure_approximations/#log-normal_closure">log-normal MA</a>). Then we can implement a simple loss function by comparing the moments predicted by the approximate model with those obtained from data:</p><pre><code class="language-julia hljs">using MomentClosure

LV_moments = moment_closure(generate_raw_moment_eqs(LV, 2), &quot;log-normal&quot;)
u0map = deterministic_IC(u0, LV_moments)
closed_moment_prob = ODEProblem(LV_moments, u0map, (0.0, Tf), zeros(5))
function obj_MCA(p)
    prob = remake(closed_moment_prob; p=p)
    sol = solve(prob, Tsit5(), saveat = t_data)
    if sol.retcode == ReturnCode.Success
        obj = sum(norm(sol.u[i][1:2] - means[i])^2 for i in 1:length(t_data))
        obj += 1e4*sum((sol.u[i][3] - sol.u[i][1]^2  - vars[i][1])^2 for i in 1:length(t_data))
        obj += 1e4*sum((sol.u[i][5] - sol.u[i][2]^2  - vars[i][2])^2 for i in 1:length(t_data))
    else
        obj = 1e6
    end
    return obj
end</code></pre><p>As before, any suitable optimisation routine can now be used to identify parameter values that result in a match between data and model prediction:</p><pre><code class="language-julia hljs">pmap = Dict(i =&gt; parameters(LV_moments.odes)[i] for i in 1:5)
p_init = Dict(γ[1] =&gt; 1.3, γ[2] =&gt; 1.5, γ[3] =&gt; 1.4, γ[4] =&gt; 2.2, γ[5] =&gt; 0.1)
p = [p_init[pmap[i]] for i in 1:5]
opt_MCA = Optim.optimize(obj_MCA, p, Optim.Options(time_limit = min(120, opt_sampling.time_run)))</code></pre><pre><code class="language-julia hljs">* Status: success

 * Candidate solution
    Final objective value:     1.160452e+00

 * Found with
    Algorithm:     Nelder-Mead

 * Convergence measures
    √(Σ(yᵢ-ȳ)²)/n ≤ 1.0e-08

 * Work counters
    Seconds run:   0  (vs limit 120)
    Iterations:    362
    f(x) calls:    751</code></pre><p>By visualising the results we see that indeed the identified parameters now provide a better match between data and the model, even if the original SDE model is being evaluated (note that the moment equations using log-normal MA provide a reasonably accurate approximation to the ensemble averages):</p><pre><code class="language-julia hljs">p_opt = [pmap[i] =&gt; opt_MCA.minimizer[i] for i in 1:5]
t_detail = collect(0:0.01:Tf) 
opt_sol = solve(EnsembleProblem(SDEProblem(LV, u0, (0.0, Tf), p_opt)), saveat = t_detail, trajectories = 1000)
opt_means = [timestep_mean(opt_sol, i) for i in 1:length(t_detail)]
opt_vars = [timestep_meanvar(opt_sol, i)[2] for i in 1:length(t_detail)]

opt_sol_approx = solve(ODEProblem(LV_moments, u0map, (0.0, Tf), p_opt), saveat = t_detail)

mean_comp = scatter(t_data, [m[1] for m in means], color = :blue,
                     xlabel = &quot;time&quot;, ylabel = &quot;population size&quot;, 
                     grid = false, title = &quot;means&quot;, label = &quot;⟨x⟩ data&quot;)
scatter!(mean_comp, t_data, [m[2] for m in means], color = :red, label = &quot;⟨y⟩ data&quot;)
plot!(mean_comp, t_detail, [m[1] for m in opt_means], linewidth = 2, color = :blue, label = &quot;⟨x⟩ SDE model&quot;)
plot!(mean_comp, t_detail, [m[2] for m in opt_means], linewidth = 2, color = :red, label = &quot;⟨y⟩ SDE model&quot;)
plot!(mean_comp, t_detail, [m[1] for m in opt_sol_approx.u], linewidth = 2, color = :black, linestyle = :dash, label = &quot;log-normal MA&quot;)
plot!(mean_comp, t_detail, [m[2] for m in opt_sol_approx.u], linewidth = 2, color = :black, linestyle = :dash, label = nothing)

var_comp = scatter(t_data, [v[1] for v in vars], color = :blue,
                   xlabel = &quot;time&quot;, title = &quot;variances&quot;, grid = false, label = &quot;σ²(x) data&quot;, legend = :topleft)
scatter!(var_comp, t_data, [v[2] for v in vars], color = :red, label = &quot;σ²(y) data&quot;)
plot!(var_comp, t_detail, [v[1] for v in opt_vars], color = :blue, label = &quot;σ²(x) SDE model&quot;)
plot!(var_comp, t_detail, [v[2] for v in opt_vars], color = :red, label = &quot;σ²(y) SDE model&quot;)
plot!(var_comp, t_detail, [m[3] - m[1]^2 for m in opt_sol_approx.u], linewidth = 2, color = :black, linestyle = :dash, label = &quot;log-normal MA&quot;)
plot!(var_comp, t_detail, [m[5] - m[2]^2 for m in opt_sol_approx.u], linewidth = 2, color = :black, linestyle = :dash, label = nothing)

plot(mean_comp, var_comp, size = (1200.0, 400.0))</code></pre><p><img src="../../assets/LV_SDE_fig2.svg" alt="LV SDE fig2"/></p><p>Finally, note that the parameter estimation is much faster using moment equations (compare to 120 s using the basic approach)</p><pre><code class="language-julia hljs">opt_MCA.time_run</code></pre><pre><code class="language-julia hljs">0.10686397552490234</code></pre></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../LMA_example/">« LMA Example</a><a class="docs-footer-nextpage" href="../../api/momentclosure_api/">MomentClosure.jl API »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="auto">Automatic (OS)</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.0.1 on <span class="colophon-date" title="Tuesday 26 September 2023 01:25">Tuesday 26 September 2023</span>. Using Julia version 1.9.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
