<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Geometrically Distributed Reaction Products and Conditional Closures · MomentClosure.jl</title><meta name="title" content="Geometrically Distributed Reaction Products and Conditional Closures · MomentClosure.jl"/><meta property="og:title" content="Geometrically Distributed Reaction Products and Conditional Closures · MomentClosure.jl"/><meta property="twitter:title" content="Geometrically Distributed Reaction Products and Conditional Closures · MomentClosure.jl"/><meta name="description" content="Documentation for MomentClosure.jl."/><meta property="og:description" content="Documentation for MomentClosure.jl."/><meta property="twitter:description" content="Documentation for MomentClosure.jl."/><meta property="og:url" content="https://augustinas1.github.io/MomentClosure.jl/tutorials/geometric_reactions+conditional_closures/"/><meta property="twitter:url" content="https://augustinas1.github.io/MomentClosure.jl/tutorials/geometric_reactions+conditional_closures/"/><link rel="canonical" href="https://augustinas1.github.io/MomentClosure.jl/tutorials/geometric_reactions+conditional_closures/"/><script data-outdated-warner src="../../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../search_index.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MomentClosure.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../../theory/moment_expansion_CME/">Moment Expansion (CME)</a></li><li><a class="tocitem" href="../../theory/moment_expansion_SDE/">Moment Expansion (SDE)</a></li><li><a class="tocitem" href="../../theory/moment_closure_approximations/">Moment Closure Approximations</a></li><li><a class="tocitem" href="../../theory/linear_mapping_approximation/">Linear Mapping Approximation</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li><a class="tocitem" href="../using_momentclosure/">Using MomentClosure</a></li><li><a class="tocitem" href="../using_momentclosure_SDE/">Moment Equations from SDEs</a></li><li><a class="tocitem" href="../common_issues/">Common Issues</a></li><li><a class="tocitem" href="../time-dependent_propensities/">Time-dependent Propensity Functions</a></li><li class="is-active"><a class="tocitem" href>Geometrically Distributed Reaction Products and Conditional Closures</a><ul class="internal"><li><a class="tocitem" href="#References"><span>References</span></a></li></ul></li><li><a class="tocitem" href="../P53_system_example/">P53 System Example</a></li><li><a class="tocitem" href="../derivative_matching_example/">Derivative Matching Example</a></li><li><a class="tocitem" href="../SIR_example/">SIR Model Example</a></li><li><a class="tocitem" href="../LMA_example/">LMA Example</a></li><li><a class="tocitem" href="../parameter_estimation_SDE/">Parameter Estimation of Diffusion Processes</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../api/momentclosure_api/">MomentClosure.jl API</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Geometrically Distributed Reaction Products and Conditional Closures</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Geometrically Distributed Reaction Products and Conditional Closures</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/augustinas1/MomentClosure.jl/blob/main/docs/src/tutorials/geometric_reactions+conditional_closures.md#L" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="geometric-and-conditional"><a class="docs-heading-anchor" href="#geometric-and-conditional">Geometrically Distributed Reaction Products and Conditional Closures</a><a id="geometric-and-conditional-1"></a><a class="docs-heading-anchor-permalink" href="#geometric-and-conditional" title="Permalink"></a></h1><p>In this tutorial, we demonstrate using <a href="https://github.com/SciML/Catalyst.jl">Catalyst</a> how to define chemical systems involving reactions which products are geometrically distributed random variables. As an example, we consider an autoregulatory (repressive) genetic feedback loop where proteins are expressed in bursts with a geometric burst size distribution, as described by Soltani et al. [1]. Moreover, the state of the gene is modelled as a binary variable—we demonstrate how conditional derivative matching and conditional gaussian closures can be used to approximate such systems, in turn reproducing a number of results from Ref. [1].</p><p>We consider a negative feedback loop described by the following reactions:</p><p class="math-container">\[\begin{align*}
G^* &amp;\stackrel{k_{on}}{\rightarrow} G, \\
G + &amp;\stackrel{k_{off}*P^2}{\rightarrow} G^*, \\
G  &amp;\stackrel{k_p}{\rightarrow} G + mP, \\
P &amp;\stackrel{\gamma_p}{\rightarrow} ∅.
\end{align*}\]</p><p>A gene in the network switches between ON (<span>$G$</span>) and OFF (<span>$G^{\\*}$</span>) states: proteins are produced in the transcriptionally active ON state but the gene can be turned OFF by two protein molecules binding to the promoter region and thus blocking transcription (proteins decay at a constant rate irrespective of the gene state). Note that the gene state can be interpreted as a distinct species that have either zero or one copy number per cell. In other words, it is a Bernoulli random variable: <span>$0$</span> in the OFF state and <span>$1$</span> in the ON state.</p><p>The transcription (mRNA) dynamics are not modelled explicitly in this gene circuit. Instead, under the assumption of fast mRNA decay, proteins are taken to be produced in bursts of size <span>$m$</span>, where <span>$m$</span> is a random variable sampled from the geometric distribution <span>$\phi(m) = b^m/(1+b)^{m+1}$</span> (with <span>$b$</span> denoting the mean burst size) [2]. Chemical reaction networks that include reactions which products are independent geometrically distributed random variables (or other symbolic variables) can be defined using <a href="https://github.com/SciML/Catalyst.jl">Catalyst</a> as demonstrated <a href="https://docs.sciml.ai/Catalyst/stable/model_creation/parametric_stoichiometry/#Gene-expression-with-randomly-produced-amounts-of-protein">in this tutorial</a>. Note that the referenced tutorial refers back to this tutorial because in the ancient times Catalyst did not provided such functionality and the previous iteration of MomentClosure implemented a <code>ReactionSystemMod</code> type that offered limited support for such systems (now deprecated as Catalyst does it better in a unified API).</p><p>Using <code>Catalyst</code>, our gene network model can be constructed as follows:</p><pre><code class="language-julia hljs"># load all the packages we will need
using MomentClosure, Catalyst, Distributions, JumpProcesses, DiffEqBase, OrdinaryDiffEq, DiffEqBase.EnsembleAnalysis, Plots, Latexify

# Proteins are produced in bursts of size m, where m is a geometric random variable with mean b.
# Note that if b is the mean burst size, then p = 1/(1+b). 
# Implemented by first registering the distribution with Symbolics
@register_symbolic Distributions.Geometric(b)
@parameters b
m = rand(Distributions.Geometric(1/(1+b)))

rn = @reaction_network begin
      @parameters k_on k_off k_p γ_p
      k_on*(1-g), 0 --&gt; g  # G* -&gt; G
      k_off*P^2, g --&gt; 0   # G -&gt; G*
      k_p, g --&gt; g + $m*P  # G -&gt; G + mP, m ~ Geometric(p)
      γ_p, P --&gt; 0         # P -&gt; ∅
end</code></pre><p>We can now generate the raw moment equations up to third order:</p><pre><code class="language-julia hljs">eqs = generate_raw_moment_eqs(rn, 3)
latexify(eqs)</code></pre><p class="math-container">\[\begin{align*}
\frac{d\mu_{1 0}}{dt} =&amp; k_{on} - k_{off} \mu_{1 2} - k_{on} \mu_{1 0} \\
\frac{d\mu_{0 1}}{dt} =&amp; b k_{p} \mu_{1 0} - \gamma_{p} \mu_{0 1} \\
\frac{d\mu_{2 0}}{dt} =&amp; k_{on} + k_{off} \mu_{1 2} + k_{on} \mu_{1 0} - 2 k_{on} \mu_{2 0} - 2 k_{off} \mu_{2 2} \\
\frac{d\mu_{1 1}}{dt} =&amp; k_{on} \mu_{0 1} + b k_{p} \mu_{2 0} - k_{on} \mu_{1 1} - \gamma_{p} \mu_{1 1} - k_{off} \mu_{1 3} \\
\frac{d\mu_{0 2}}{dt} =&amp; \gamma_{p} \mu_{0 1} + b k_{p} \mu_{1 0} + 2 b k_{p} \mu_{1 1} + 2 k_{p} b^{2} \mu_{1 0} - 2 \gamma_{p} \mu_{0 2} \\
\frac{d\mu_{3 0}}{dt} =&amp; k_{on} + 3 k_{off} \mu_{2 2} + 2 k_{on} \mu_{1 0} - k_{off} \mu_{1 2} - 3 k_{off} \mu_{3 2} - 3 k_{on} \mu_{3 0} \\
\frac{d\mu_{2 1}}{dt} =&amp; k_{on} \mu_{0 1} + k_{on} \mu_{1 1} + k_{off} \mu_{1 3} + b k_{p} \mu_{3 0} - 2 k_{on} \mu_{2 1} - \gamma_{p} \mu_{2 1} - 2 k_{off} \mu_{2 3} \\
\frac{d\mu_{1 2}}{dt} =&amp; k_{on} \mu_{0 2} + \gamma_{p} \mu_{1 1} + b k_{p} \mu_{2 0} + 2 k_{p} b^{2} \mu_{2 0} + 2 b k_{p} \mu_{2 1} - k_{off} \mu_{1 4} - k_{on} \mu_{1 2} - 2 \gamma_{p} \mu_{1 2} \\
\frac{d\mu_{0 3}}{dt} =&amp; b k_{p} \mu_{1 0} + 3 \gamma_{p} \mu_{0 2} + 3 b k_{p} \mu_{1 1} + 3 b k_{p} \mu_{1 2} + 6 k_{p} b^{2} \mu_{1 0} + 6 k_{p} b^{3} \mu_{1 0} + 6 k_{p} b^{2} \mu_{1 1} - \gamma_{p} \mu_{0 1} - 3 \gamma_{p} \mu_{0 3}
\end{align*}\]</p><p>A lot of information in this system of ODEs is redundant as the gene state is a Bernoulli variable that (in our case) has the following properties:</p><p class="math-container">\[\begin{align*}
μ_{j0} &amp;= μ_{10}, \quad j \in {2, 3, \dotsc}, \\
μ_{jk} &amp;= μ_{1k}, \quad j,k \in {1, 2, 3, \dotsc}
\end{align*}\]</p><p>We can <em>clean</em> the moment equations accordingly by specifying which molecule numbers are Bernoulli variables and using the <a href="../../api/momentclosure_api/#MomentClosure.bernoulli_moment_eqs"><code>bernoulli_moment_eqs</code></a> function:</p><pre><code class="language-julia hljs"># specify the indices of species which molecule numbers are binary
binary_vars = [1]
# simplify the moment equations using properties of Bernoulli variables
clean_eqs = bernoulli_moment_eqs(eqs, binary_vars)
latexify(clean_eqs)</code></pre><p class="math-container">\[\begin{align*}
\frac{d\mu_{1 0}}{dt} =&amp; k_{on} - k_{off} \mu_{1 2} - k_{on} \mu_{1 0} \\
\frac{d\mu_{0 1}}{dt} =&amp; b k_{p} \mu_{1 0} - \gamma_{p} \mu_{0 1} \\
\frac{d\mu_{1 1}}{dt} =&amp; k_{on} \mu_{0 1} + b k_{p} \mu_{1 0} - k_{on} \mu_{1 1} - \gamma_{p} \mu_{1 1} - k_{off} \mu_{1 3} \\
\frac{d\mu_{0 2}}{dt} =&amp; \gamma_{p} \mu_{0 1} + b k_{p} \mu_{1 0} + 2 b k_{p} \mu_{1 1} + 2 k_{p} b^{2} \mu_{1 0} - 2 \gamma_{p} \mu_{0 2} \\
\frac{d\mu_{1 2}}{dt} =&amp; k_{on} \mu_{0 2} + \gamma_{p} \mu_{1 1} + b k_{p} \mu_{1 0} + 2 b k_{p} \mu_{1 1} + 2 k_{p} b^{2} \mu_{1 0} - k_{off} \mu_{1 4} - k_{on} \mu_{1 2} - 2 \gamma_{p} \mu_{1 2} \\
\frac{d\mu_{0 3}}{dt} =&amp; b k_{p} \mu_{1 0} + 3 \gamma_{p} \mu_{0 2} + 3 b k_{p} \mu_{1 1} + 3 b k_{p} \mu_{1 2} + 6 k_{p} b^{2} \mu_{1 0} + 6 k_{p} b^{3} \mu_{1 0} + 6 k_{p} b^{2} \mu_{1 1} - \gamma_{p} \mu_{0 1} - 3 \gamma_{p} \mu_{0 3}
\end{align*}\]</p><p>The system of ODEs is now much simpler and we can see that there are two higher-order moments we need to truncate: <span>$\mu_{13}$</span> and <span>$μ_{14}$</span>. We consider normal, derivative matching, conditional gaussian and conditional derivative matching closures to see how well they compare. First we apply different closures and print out the corresponding higher-order moment expressions in order to check that our results are consistent with those published in [1].</p><p>For normal closure:</p><pre><code class="language-julia hljs">normal_eqs = moment_closure(eqs, &quot;normal&quot;, binary_vars)
latexify(normal_eqs, :closure)</code></pre><p class="math-container">\[\begin{align*}
\mu{_{13}} =&amp; \mu{_{03}} \mu{_{10}} + 3 \mu{_{01}} \mu{_{12}} + 3 \mu{_{02}} \mu{_{11}} + 6 \mu{_{10}} \mu{_{01}}^{3} - 6 \mu{_{11}} \mu{_{01}}^{2} - 6 \mu{_{01}} \mu{_{02}} \mu{_{10}} \\
\mu{_{14}} =&amp; \mu{_{04}} \mu{_{10}} + 4 \mu{_{01}} \mu{_{13}} + 6 \mu{_{02}} \mu{_{12}} + 4 \mu{_{03}} \mu{_{11}} + 24 \mu{_{11}} \mu{_{01}}^{3} + 36 \mu{_{02}} \mu{_{10}} \mu{_{01}}^{2} - 24 \mu{_{10}} \mu{_{01}}^{4} - 6 \mu{_{10}} \mu{_{02}}^{2} - 12 \mu{_{12}} \mu{_{01}}^{2} - 24 \mu{_{01}} \mu{_{02}} \mu{_{11}} - 8 \mu{_{01}} \mu{_{03}} \mu{_{10}}
\end{align*}\]</p><p>Note that our expression for <span>$μ_{14}$</span> is different from the equivalent <span>$\langle gp^4 \rangle$</span> in Eq. (8) of [1] as it seems that the authors introduced a mistake considering the central moment and cumulant relationship in Eq. (7).</p><p>Using derivative matching, we obtain:</p><pre><code class="language-julia hljs">dm_eqs = moment_closure(eqs, &quot;derivative matching&quot;, binary_vars)
latexify(dm_eqs, :closure)</code></pre><p class="math-container">\[\begin{align*}
\mu_{1 3} =&amp; \frac{\mu_{0 1}^{3} \mu_{1 2}^{3} \mu_{0 3} \mu_{1 0}}{\mu_{0 2}^{3} \mu_{1 1}^{3}} \\
\mu_{1 4} =&amp; \frac{\mu_{0 2}^{6} \mu_{1 1}^{4} \mu_{1 3}^{4} \mu_{0 4}}{\mu_{0 1}^{4} \mu_{0 3}^{4} \mu_{1 2}^{6} \mu_{1 0}}
\end{align*}\]</p><p>For conditional gaussian closure:</p><pre><code class="language-julia hljs">cond_gaussian_eqs = moment_closure(eqs, &quot;conditional gaussian&quot;, binary_vars)
latexify(cond_gaussian_eqs, :closure)</code></pre><p class="math-container">\[\begin{align*}
\mu_{1 3} =&amp; \frac{-2 \mu_{1 1}^{3}}{\mu_{1 0}^{2}} + \frac{3 \mu_{1 1} \mu_{1 2}}{\mu_{1 0}} \\
\mu_{1 4} =&amp; \frac{3 \mu_{1 2}^{2}}{\mu_{1 0}} + \frac{6 \mu_{1 1}^{4}}{\mu_{1 0}^{3}} + \frac{-12 \mu_{1 1}^{2} \mu_{1 2}}{\mu_{1 0}^{2}} + \frac{4 \mu_{1 1} \mu_{1 3}}{\mu_{1 0}}
\end{align*}\]</p><p>And, finally, for conditional derivative matching:</p><pre><code class="language-julia hljs">cond_dm_eqs = moment_closure(eqs, &quot;conditional derivative matching&quot;, binary_vars)
latexify(cond_dm_eqs, :closure)</code></pre><p class="math-container">\[\begin{align*}
\mu_{1 3} =&amp; \frac{\mu_{0 1}^{3} \mu_{1 2}^{3} \mu_{0 3} \mu_{1 0}}{\mu_{0 2}^{3} \mu_{1 1}^{3}} \\
\mu_{1 4} =&amp; \frac{\mu_{0 2}^{6} \mu_{1 1}^{4} \mu_{1 3}^{4} \mu_{0 4}}{\mu_{0 1}^{4} \mu_{0 3}^{4} \mu_{1 2}^{6} \mu_{1 0}}
\end{align*}\]</p><p>All these results are consistent with [1], reassuring that the model and closures are implemented as intended. Finally, we can proceed to solve the resulting ODEs and compare the resulting means and standard deviations to the SSA. Following Soltani et al. [1], we define all model parameters as:</p><pre><code class="language-julia hljs">mean_p = 200
mean_b = 70
γ_p_val = 1
k_off_val = 0.001
k_on_val = 0.05

k_p_val = mean_p * γ_p_val * (k_off_val * mean_p^2 + k_on_val) / (k_on_val * mean_b)

pmap = [:k_on =&gt; k_on_val,
          :k_off =&gt; k_off_val,
          :k_p =&gt; k_p_val,
          :γ_p =&gt; γ_p_val,
          :b =&gt; mean_b]

# initial gene state and protein number
u0map = [:g =&gt; 1, :P =&gt; 1]

# time interval to solve on
tspan = (0., 6.0)</code></pre><p>The reaction network with geometric bursts can be simulated using the SSA as usual:</p><pre><code class="language-julia hljs"># convert the reaction network into a system of jump processes
jsys = convert(JumpSystem, rn; combinatoric_ratelaws=false)
jsys = complete(jsys)

# create a discrete problem setting the simulation parameters
dprob = DiscreteProblem(u0map, tspan, pmap)

# create a JumpProblem compatible with ReactionSystemMod
jprob = JumpProblem(rn, dprob, Direct(), save_positions=(false, false))

# simulate 2×10⁴ SSA trajectories
ensembleprob  = EnsembleProblem(jprob)
@time sol_SSA = solve(ensembleprob, SSAStepper(), saveat=0.1, trajectories=20000)
# compute the means and variances
means_ssa, vars_ssa = timeseries_steps_meanvar(sol_SSA)</code></pre><pre><code class="language-julia hljs">4.858357 seconds (14.30 M allocations: 901.032 MiB, 6.25% gc time, 63.45% compilation time)</code></pre><p>We continue to solve the moment equations for each closure:</p><pre><code class="language-julia hljs">plt_m = plot()   # plot mean protein number
plt_std = plot() # plot ssd of protein number

# solve moment ODEs for each closure and plot the results
for closure in [&quot;normal&quot;, &quot;derivative matching&quot;,
                &quot;conditional gaussian&quot;, &quot;conditional derivative matching&quot;]

    # it is very quick so we just apply all closures again
    closed_eqs = moment_closure(eqs, closure, binary_vars)

    # solve the system of moment ODEs
    oprob = ODEProblem(closed_eqs, u0map, tspan, pmap)
    sol = solve(oprob, AutoTsit5(Rosenbrock23()), saveat=0.01)

    # μ₀₁ is 2nd and μ₀₂ is 4th element in sol
    # can check the order with `closed_eqs.odes.states`
    plt_m = plot!(plt_m, sol, idxs=[2], label=closure)
    plt_std = plot!(plt_std, sol.t, sqrt.(sol[4, :] .- sol[2, :].^2), label=closure)

end

plt_m = plot!(plt_m, xlabel=&quot;Time [hr]&quot;, ylabel=&quot;Protein mean level&quot;)
plt_m = plot!(plt_m, means_ssa.t, means_ssa[2,:], label=&quot;SSA&quot;, linestyle=:dash, color=&quot;gray&quot;)
plt_std = plot!(plt_std, xlabel=&quot;Time [hr]&quot;, ylabel=&quot;Protein standard deviation&quot;)
plt_std = plot!(plt_std, vars_ssa.t, sqrt.(vars_ssa[2,:]), label=&quot;SSA&quot;, linestyle=:dash, color=&quot;gray&quot;)</code></pre><pre><code class="language-julia hljs">plot(plt_m, lw=2)</code></pre><p><img src="../../assets/gene_1_means.svg" alt="Gene 1 means"/></p><pre><code class="language-julia hljs">plot(plt_std, lw=2)</code></pre><p><img src="../../assets/gene_1_stds.svg" alt="Gene 2 stds"/></p><p>We observe that the two conditional closures give the most accurate results. Therefore, closing moments conditioned on the gene being active is an effective approximation in this case. Note that our results for normal closure are different from [1], most likely due to the incorrect fifth-order moment closure function given in the paper.</p><p>We now turn to a more complex network involving two genes (two Bernoulli variables), a repressor-activator circuit: an activator protein <span>$Y$</span> expressed by one gene can turn ON another gene which produces a repressor protein <span>$X$</span>, that subsequently can bind to the gene promoter region of the activator-producing gene turning it OFF (see [1] for more details). As before, <span>$X$</span> and <span>$Y$</span> proteins are expressed in geometrically-distributed bursts. The system can be specified as follows:</p><pre><code class="language-julia hljs">@parameters b_x b_y
# could redefine in terms of success probabilities p_x and p_y as above
m = rand(Distributions.Geometric(1/(1+b_x)))
l = rand(Distributions.Geometric(1/(1+b_y)))

# g_x - gene state of X protein producing gene
# g_y - gene state of Y protein producing gene
# x, y - proteins X and Y
rn = @reaction_network begin
      @parameters kx_on kx_off ky_on ky_off k_x γ_x k_y γ_y
      kx_on*(1-g_x)*y, 0 --&gt; g_x  # 0   -&gt; g_x
      kx_off,          g_x --&gt; 0  # g_x -&gt; 0
      ky_on*(1-g_y),   0 --&gt; g_y  # 0 -&gt; g_y
      ky_off*x,        g_y --&gt; 0  # g_y -&gt; 0
      k_x*g_x,         0 --&gt; $m*x # 0 -&gt; mx, m ~ Geometric(mean=b_x)
      γ_x,             x --&gt; 0    # x -&gt; 0
      k_y*g_y,         0 --&gt; $l*y # 0 -&gt; ly, l ~ Geometric(mean_b_y)
      γ_y,             y --&gt; 0    # y -&gt; 0
end

# both g_x and g_y are Bernoulli random variables
binary_vars = [1, 2]

# Parameter initialisation

mean_x = 100
mean_y = 100
mean_b_x = 5
mean_b_y = 5
γ_x_val = 1
γ_y_val = 1
kx_off_val = 4
ky_on_val = 0.3
kx_on_val = 0.05
ky_off_val = 0.05

k_x_val = mean_x * γ_x_val * (kx_off_val * mean_y^2 + kx_on_val) / (kx_on_val * mean_b_x)
k_y_val = mean_y * γ_y_val * (ky_off_val * mean_x^2 + ky_on_val) / (ky_on_val * mean_b_y)

# unclear if Soltani et al. (2015) actually used this parameter set as X numbers
# jump to millions making SSA extremely slow...

# introduce additional rescaling (otherwise rate coefficients are too high)
k_x_val *= 0.00003
k_y_val *= 0.01

# parameter mapping
pmap = [:kx_on =&gt; kx_on_val,
          :kx_off =&gt; kx_off_val,
          :ky_on =&gt; ky_on_val,
          :ky_off =&gt; ky_off_val,
          :k_x =&gt; k_x_val,
          :k_y =&gt; k_y_val,
          :γ_x =&gt; γ_x_val,
          :γ_y =&gt; γ_y_val,
          :b_x =&gt; mean_b_x,
          :b_y =&gt; mean_b_y]

# initial gene state and protein number, order [g_x, g_y, x, y]
u0map = [:g_x =&gt; 1, :g_y =&gt; 1, :x =&gt; 1, :y =&gt; 1]

# time interval to solve on
tspan = (0., 12.0)</code></pre><p>Note that here we use a different parameter set from the one considered in [1] as otherwise the number of <span>$X$</span> proteins goes into millions, making the comparison between closure results difficult due to SSA being extremely slow—it appears that either we have included a mistake setting the parameter values or there is a typo in the paper.</p><p>We can run SSA as follows:</p><pre><code class="language-julia hljs">jsys = convert(JumpSystem, rn, combinatoric_ratelaws=false)
jsys = complete(jsys)
dprob = DiscreteProblem(jsys, u0map, tspan, pmap)
jprob = JumpProblem(jsys, dprob, Direct(), save_positions=(false, false))

ensembleprob  = EnsembleProblem(jprob)
@time sol_SSA = solve(ensembleprob, SSAStepper(), saveat=0.1, trajectories=10000)
means_ssa, vars_ssa = timeseries_steps_meanvar(sol_SSA)</code></pre><pre><code class="language-julia hljs">13.712331 seconds (43.27 M allocations: 1.697 GiB, 6.56% gc time, 10.01% compilation time)</code></pre><p>We use fourth order moment expansion and apply different closure methods as done for the negative feedback loop, considering the number of activator proteins <span>$Y$</span> and its standard deviation:</p><pre><code class="language-julia hljs">plt_m = plot()   # plot mean activator protein number
plt_std = plot() # plot ssd of activator protein number

for closure in [&quot;derivative matching&quot;, &quot;conditional derivative matching&quot;]

    closed_eqs = moment_closure(eqs, closure, binary_vars)
    oprob = ODEProblem(closed_eqs, u0map, tspan, pmap)
    sol = solve(oprob, Tsit5(), saveat=0.1)

    # μ₀₀₀₁ is the 4th and μ₀₀₀₂ is the 12th element in sol (can check with closed_eqs.odes.states)
    plt_m = plot!(plt_m, sol, idxs=[4], label=closure)
    plt_std = plot!(plt_std, sol.t, sqrt.(sol[12, :] .- sol[4, :].^2), label=closure)
end

plt_m = plot!(plt_m, xlabel=&quot;Time [hr]&quot;, ylabel=&quot;Activator mean level&quot;)
plt_m = plot!(plt_m, means_ssa.t, means_ssa[4,:], label=&quot;SSA&quot;, linestyle=:dash, color=&quot;gray&quot;)
plt_std = plot!(plt_std, xlabel=&quot;Time [hr]&quot;, ylabel=&quot;Activator standard deviation&quot;)
plt_std = plot!(plt_std, vars_ssa.t, sqrt.(vars_ssa[4,:]), label=&quot;SSA&quot;, linestyle=:dash, color=&quot;gray&quot;)</code></pre><p>Note that here we apply only derivative matching and conditional derivative matching, as both normal and conditional gaussian closures failed to be evaluated for the entire time course (irrespective of the solver used). Finally, we can plot the results:</p><pre><code class="language-julia hljs">plot(plt_m, lw=2)</code></pre><p><img src="../../assets/gene_2_means.svg" alt="Gene 2 means"/></p><pre><code class="language-julia hljs">plot(plt_std, lw=2, xlims=(0., 12.))</code></pre><p><img src="../../assets/gene_2_stds.svg" alt="Gene 2 stds"/></p><p>The trajectories obtained with conditional derivative matching quite accurately match the true dynamics, showing that it is indeed a powerful closure method for reaction networks involving species with very low (binary) copy numbers.</p><h2 id="References"><a class="docs-heading-anchor" href="#References">References</a><a id="References-1"></a><a class="docs-heading-anchor-permalink" href="#References" title="Permalink"></a></h2><p>[1]: M. Soltani, C. A. Vargas-Garcia, and A. Singh, &quot;Conditional Moment Closure Schemes for Studying Stochastic Dynamics of Genetic Circuits&quot;, IEEE Transactions on Biomedical Circuits and Systems 9, 518–526 (2015). <a href="https://doi.org/10.1109/tbcas.2015.2453158">https://doi.org/10.1109/tbcas.2015.2453158</a></p><p>[2]: D. Schnoerr, G. Sanguinetti, and R. Grima, &quot;Approximation and inference methods for stochastic biochemical kinetics - a tutorial review&quot;, Journal of Physics A: Mathematical and Theoretical 50, 093001 (2017). <a href="https://doi.org/10.1088/1751-8121/aa54d9">https://doi.org/10.1088/1751-8121/aa54d9</a></p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../time-dependent_propensities/">« Time-dependent Propensity Functions</a><a class="docs-footer-nextpage" href="../P53_system_example/">P53 System Example »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.11.4 on <span class="colophon-date" title="Monday 2 June 2025 07:59">Monday 2 June 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
