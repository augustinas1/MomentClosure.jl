<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Using MomentClosure · MomentClosure.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://augustinas1.github.io/MomentClosure.jl/tutorials/using_momentclosure/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.044/juliamono.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><div class="docs-package-name"><span class="docs-autofit"><a href="../../">MomentClosure.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Theory</span><ul><li><a class="tocitem" href="../../theory/moment_expansion_CME/">Moment Expansion (CME)</a></li><li><a class="tocitem" href="../../theory/moment_expansion_SDE/">Moment Expansion (SDE)</a></li><li><a class="tocitem" href="../../theory/moment_closure_approximations/">Moment Closure Approximations</a></li><li><a class="tocitem" href="../../theory/linear_mapping_approximation/">Linear Mapping Approximation</a></li></ul></li><li><span class="tocitem">Tutorials</span><ul><li class="is-active"><a class="tocitem" href>Using MomentClosure</a><ul class="internal"><li><a class="tocitem" href="#Model-Initialisation"><span>Model Initialisation</span></a></li><li><a class="tocitem" href="#Generating-Moment-Equations"><span>Generating Moment Equations</span></a></li><li><a class="tocitem" href="#Applying-Moment-Closure"><span>Applying Moment Closure</span></a></li><li><a class="tocitem" href="#Solving-Moment-Equations"><span>Solving Moment Equations</span></a></li><li><a class="tocitem" href="#Stochastic-Simulation"><span>Stochastic Simulation</span></a></li></ul></li><li><a class="tocitem" href="../using_momentclosure_SDE/">Moment Equations from SDEs</a></li><li><a class="tocitem" href="../common_issues/">Common Issues</a></li><li><a class="tocitem" href="../time-dependent_propensities/">Time-dependent Propensity Functions</a></li><li><a class="tocitem" href="../geometric_reactions+conditional_closures/">Geometrically Distributed Reaction Products and Conditional Closures</a></li><li><a class="tocitem" href="../P53_system_example/">P53 System Example</a></li><li><a class="tocitem" href="../derivative_matching_example/">Derivative Matching Example</a></li><li><a class="tocitem" href="../SIR_example/">SIR Model Example</a></li><li><a class="tocitem" href="../LMA_example/">LMA Example</a></li><li><a class="tocitem" href="../parameter_estimation_SDE/">Parameter Estimation of Diffusion Processes</a></li></ul></li><li><span class="tocitem">API</span><ul><li><a class="tocitem" href="../../api/momentclosure_api/">MomentClosure.jl API</a></li></ul></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tutorials</a></li><li class="is-active"><a href>Using MomentClosure</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Using MomentClosure</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/augustinas1/MomentClosure.jl/blob/main/docs/src/tutorials/using_momentclosure.md#L" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="main_tutorial"><a class="docs-heading-anchor" href="#main_tutorial">Using MomentClosure</a><a id="main_tutorial-1"></a><a class="docs-heading-anchor-permalink" href="#main_tutorial" title="Permalink"></a></h1><p>This tutorial is an introduction to using MomentClosure to define chemical reaction network models, generate the corresponding moment equations, apply moment closure approximations and finally solve the resulting system of ODEs. To demonstrate this functionality, we will consider a specific case of an oscillatory chemical system known as the Brusselator, characterised by the reactions</p><p class="math-container">\[\begin{align*}
2X + Y &amp;\stackrel{c_1}{\rightarrow} 3X, \\
X &amp;\stackrel{c_2}{\rightarrow} Y, \\
∅ &amp;\underset{c_4}{\stackrel{c_3}{\rightleftharpoons}} X.
\end{align*}\]</p><p>We have chosen this particular model to start with as it has been studied with different moment closures before by <a href="https://doi.org/10.1063/1.4934990">Schnoerr et al. (2015)</a> and so it is useful as a reference point. The plots of moment trajectories we obtain in this tutorial fully reproduce some of the figures published in the paper, hence (partially) proving the validity of our implementation.</p><p>The terminology and the notation used throughout is consistent with the <strong>Theory</strong> section of the docs and we advise giving it a skim-through.</p><h2 id="Model-Initialisation"><a class="docs-heading-anchor" href="#Model-Initialisation">Model Initialisation</a><a id="Model-Initialisation-1"></a><a class="docs-heading-anchor-permalink" href="#Model-Initialisation" title="Permalink"></a></h2><p><a href="https://github.com/SciML/Catalyst.jl">Catalyst.jl</a> provides a comprehensive interface to modelling chemical reaction networks in Julia and can be used to construct models fully-compatible with MomentClosure. For more details on how to do so we recommend reading <a href="https://catalyst.sciml.ai/stable/tutorials/using_catalyst/">Catalyst&#39;s tutorial</a>. This way, the Brusselator can be defined as:</p><pre><code class="language-julia hljs">using Catalyst
rn = @reaction_network begin
  # also including system-size parameter Ω
  (c₁/Ω^2), 2X + Y → 3X
  (c₂), X → Y
  (c₃*Ω, c₄), 0 ↔ X
end c₁ c₂ c₃ c₄ Ω</code></pre><p>The returned <code>rn</code> is an instance of <a href="https://catalyst.sciml.ai/stable/api/catalyst_api/#ModelingToolkit.ReactionSystem"><code>ModelingToolkit.ReactionSystem</code></a>. The net stoichiometry matrix and an array of the corresponding propensities, if needed, can be extracted directly from the model using MomentClosure functions <a href="../../api/momentclosure_api/#Catalyst.netstoichmat"><code>netstoichmat</code></a> and <a href="../../api/momentclosure_api/#MomentClosure.propensities"><code>propensities</code></a> respectively.</p><p>Note that MomentClosure add support for systems containing geometrically distributed reaction products—see <a href="../geometric_reactions+conditional_closures/#geometric-and-conditional">this tutorial</a> for more details.</p><h2 id="Generating-Moment-Equations"><a class="docs-heading-anchor" href="#Generating-Moment-Equations">Generating Moment Equations</a><a id="Generating-Moment-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Generating-Moment-Equations" title="Permalink"></a></h2><p>We can now obtain the moment equations. The system follows the law of mass action, i.e., all propensity functions are polynomials in molecule numbers <span>$X(t)$</span> and <span>$Y(t)$</span>, and so we can generate either <em>raw</em> or <em>central</em> moment equations, as described in the <strong>Theory</strong> section on <a href="../../theory/moment_expansion_CME/#moment_expansion_CME">moment expansion</a>.</p><h4 id="Raw-Moment-Equations"><a class="docs-heading-anchor" href="#Raw-Moment-Equations">Raw Moment Equations</a><a id="Raw-Moment-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Raw-Moment-Equations" title="Permalink"></a></h4><p>Let&#39;s start with the raw moment equations which we choose to generate up to second order (<span>$m=2$</span>):</p><pre><code class="language-julia hljs">using MomentClosure
raw_eqs = generate_raw_moment_eqs(rn, 2, combinatoric_ratelaw=false)</code></pre><p>Note that we have set <code>combinatoric_ratelaw=false</code> in order to ignore the factorial scaling factors which <a href="https://catalyst.sciml.ai/stable/tutorials/models/#Reaction-rate-laws-used-in-simulations">Catalyst adds to mass-action reactions</a>. The function <a href="../../api/momentclosure_api/#MomentClosure.generate_raw_moment_eqs"><code>generate_raw_moment_eqs</code></a> returns an instance of <a href="../../api/momentclosure_api/#MomentClosure.RawMomentEquations"><code>RawMomentEquations</code></a> that contains a <a href="https://mtk.sciml.ai/stable/systems/ODESystem/"><code>ModelingToolkit.ODESystem</code></a> composed of all the moment equations (accessed by <code>raw_eqs.odes</code>).</p><p>We can use <a href="https://github.com/korsbo/Latexify.jl">Latexify</a> to look at the generated moment equations:</p><pre><code class="language-julia hljs">using Latexify
latexify(raw_eqs)</code></pre><p class="math-container">\[\begin{align*}
\frac{d\mu{_{10}}}{dt} =&amp; c{_3} \Omega + c{_1} \mu{_{21}} \Omega^{-2} - c{_2} \mu{_{10}} - c{_4} \mu{_{10}} - c{_1} \mu{_{11}} \Omega^{-2} \\
\frac{d\mu{_{01}}}{dt} =&amp; c{_2} \mu{_{10}} + c{_1} \mu{_{11}} \Omega^{-2} - c{_1} \mu{_{21}} \Omega^{-2} \\
\frac{d\mu{_{20}}}{dt} =&amp; c{_2} \mu{_{10}} + c{_3} \Omega + c{_4} \mu{_{10}} + 2 c{_1} \mu{_{31}} \Omega^{-2} + 2 c{_3} \Omega \mu{_{10}} - 2 c{_2} \mu{_{20}} - 2 c{_4} \mu{_{20}} - c{_1} \mu{_{11}} \Omega^{-2} - c{_1} \mu{_{21}} \Omega^{-2} \\
\frac{d\mu{_{11}}}{dt} =&amp; c{_2} \mu{_{20}} + c{_1} \mu{_{11}} \Omega^{-2} + c{_1} \mu{_{22}} \Omega^{-2} + c{_3} \Omega \mu{_{01}} - c{_2} \mu{_{10}} - c{_2} \mu{_{11}} - c{_4} \mu{_{11}} - c{_1} \mu{_{12}} \Omega^{-2} - c{_1} \mu{_{31}} \Omega^{-2} \\
\frac{d\mu{_{02}}}{dt} =&amp; c{_2} \mu{_{10}} + c{_1} \mu{_{21}} \Omega^{-2} + 2 c{_2} \mu{_{11}} + 2 c{_1} \mu{_{12}} \Omega^{-2} - c{_1} \mu{_{11}} \Omega^{-2} - 2 c{_1} \mu{_{22}} \Omega^{-2}
\end{align*}\]</p><p>The raw moments are defined as</p><p class="math-container">\[\mu_{ij}(t) = \langle X(t)^i Y(t)^j \rangle\]</p><p>where <span>$\langle \rangle$</span> denote the expectation value and we have explicitly included the time-dependence for completeness (made implicit in the formatted moment equations). Note that the ordering of species (<span>$X$</span> first and <span>$Y$</span> second) is consistent with the order these variables appear within the <a href="https://catalyst.sciml.ai/stable/api/catalyst_api/#Catalyst.@reaction_network"><code>Catalyst.@reaction_network</code></a> macro. The ordering can also be checked using <a href="https://catalyst.sciml.ai/stable/api/catalyst_api/#Catalyst.speciesmap"><code>Catalyst.speciesmap</code></a> function:</p><pre><code class="language-julia hljs">speciesmap(rn)</code></pre><pre><code class="language-julia hljs">Dict{Term{Real},Int64} with 2 entries:
  X(t) =&gt; 1
  Y(t) =&gt; 2</code></pre><p>Note that <a href="../../api/momentclosure_api/#Catalyst.speciesmap"><code>speciesmap</code></a> can be used in the same way with a <a href="../../api/momentclosure_api/#MomentClosure.ReactionSystemMod"><code>ReactionSystemMod</code></a>.</p><p>Coming back to the generated moment equations, we observe that they depend on higher-order moments. For example, the ODE for <span>$\mu_{02}$</span> depends on third order moments <span>$μ_{12}$</span> and <span>$μ_{21}$</span> and the fourth order moment <span>$\mu_{22}$</span>. Consider the general case of <a href="../../theory/moment_expansion_CME/#raw_moment_eqs">raw moment equations</a>: if a network involves reactions that are polynomials (in molecule numbers) of <em>at most</em> order <span>$k$</span>, then its <span>$m^{\text{th}}$</span> order moment equations will depend on moments up to order <span>$m+k-1$</span>. Hence the relationship seen above is expected as the Brusselator involves a trimolecular reaction whose corresponding propensity function is a third order polynomial in <span>$X(t)$</span> and <span>$Y(t)$</span>. The number denoting the highest order of moments encountered in the generated <a href="../../api/momentclosure_api/#MomentClosure.RawMomentEquations"><code>RawMomentEquations</code></a> can also be accessed as <code>raw_eqs.q_order</code> (returning <code>4</code> in this case).</p><h4 id="Central-Moment-Equations"><a class="docs-heading-anchor" href="#Central-Moment-Equations">Central Moment Equations</a><a id="Central-Moment-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Central-Moment-Equations" title="Permalink"></a></h4><p>The corresponding central moment equations can also be easily generated:</p><pre><code class="language-julia hljs">central_eqs = generate_central_moment_eqs(rn, 2, combinatoric_ratelaw=false)</code></pre><p>Note that in case of non-polynomial propensity functions the <a href="../../theory/moment_expansion_CME/#central_moment_eqs">Taylor expansion order <span>$q$</span></a> must also be specified, see the <a href="../P53_system_example/">P53 system example</a> for more details. Luckily, the Brusselator contains only mass-action reactions and hence <span>$q$</span> is automatically determined by the highest order (polynomial) propensity. The function <a href="../../api/momentclosure_api/#MomentClosure.generate_central_moment_eqs"><code>generate_central_moment_eqs</code></a> returns an instance of <a href="../../api/momentclosure_api/#MomentClosure.CentralMomentEquations"><code>CentralMomentEquations</code></a>. As before, we can visualise the central moment equations:</p><pre><code class="language-julia hljs">latexify(central_eqs)</code></pre><p class="math-container">\[\begin{align*}
\frac{d\mu{_{10}}}{dt} =&amp; c{_3} \Omega + c{_1} M{_{21}} \Omega^{-2} + c{_1} M{_{20}} \mu{_{01}} \Omega^{-2} + c{_1} \mu{_{01}} \Omega^{-2} \mu{_{10}}^{2} + 2 c{_1} M{_{11}} \mu{_{10}} \Omega^{-2} - c{_2} \mu{_{10}} - c{_4} \mu{_{10}} - c{_1} M{_{11}} \Omega^{-2} - c{_1} \mu{_{01}} \mu{_{10}} \Omega^{-2} \\
\frac{d\mu{_{01}}}{dt} =&amp; c{_2} \mu{_{10}} + c{_1} M{_{11}} \Omega^{-2} + c{_1} \mu{_{01}} \mu{_{10}} \Omega^{-2} - c{_1} M{_{21}} \Omega^{-2} - 2 c{_1} M{_{11}} \mu{_{10}} \Omega^{-2} - c{_1} M{_{20}} \mu{_{01}} \Omega^{-2} - c{_1} \mu{_{01}} \Omega^{-2} \mu{_{10}}^{2} \\
\frac{dM{_{20}}}{dt} =&amp; c{_2} \mu{_{10}} + c{_3} \Omega + c{_4} \mu{_{10}} + 2 c{_1} M{_{31}} \Omega^{-2} + c{_1} \mu{_{01}} \Omega^{-2} \mu{_{10}}^{2} + 2 c{_1} M{_{11}} \Omega^{-2} \mu{_{10}}^{2} + 4 c{_1} M{_{21}} \mu{_{10}} \Omega^{-2} + 2 c{_1} M{_{30}} \mu{_{01}} \Omega^{-2} + 4 c{_1} M{_{20}} \mu{_{01}} \mu{_{10}} \Omega^{-2} - 2 c{_2} M{_{20}} - 2 c{_4} M{_{20}} - c{_1} M{_{11}} \Omega^{-2} - c{_1} M{_{21}} \Omega^{-2} - c{_1} M{_{20}} \mu{_{01}} \Omega^{-2} - c{_1} \mu{_{01}} \mu{_{10}} \Omega^{-2} \\
\frac{dM{_{11}}}{dt} =&amp; c{_2} M{_{20}} + c{_1} M{_{11}} \Omega^{-2} + c{_1} M{_{22}} \Omega^{-2} + c{_1} M{_{02}} \Omega^{-2} \mu{_{10}}^{2} + c{_1} M{_{21}} \mu{_{01}} \Omega^{-2} + c{_1} \mu{_{01}} \mu{_{10}} \Omega^{-2} + 2 c{_1} M{_{12}} \mu{_{10}} \Omega^{-2} + 2 c{_1} M{_{11}} \mu{_{01}} \mu{_{10}} \Omega^{-2} - c{_2} M{_{11}} - c{_2} \mu{_{10}} - c{_4} M{_{11}} - c{_1} M{_{12}} \Omega^{-2} - c{_1} M{_{31}} \Omega^{-2} - c{_1} M{_{02}} \mu{_{10}} \Omega^{-2} - c{_1} M{_{11}} \mu{_{01}} \Omega^{-2} - c{_1} M{_{11}} \mu{_{10}} \Omega^{-2} - c{_1} M{_{11}} \Omega^{-2} \mu{_{10}}^{2} - 2 c{_1} M{_{21}} \mu{_{10}} \Omega^{-2} - c{_1} M{_{30}} \mu{_{01}} \Omega^{-2} - c{_1} \mu{_{01}} \Omega^{-2} \mu{_{10}}^{2} - 2 c{_1} M{_{20}} \mu{_{01}} \mu{_{10}} \Omega^{-2} \\
\frac{dM{_{02}}}{dt} =&amp; c{_2} \mu{_{10}} + c{_1} M{_{21}} \Omega^{-2} + 2 c{_2} M{_{11}} + 2 c{_1} M{_{12}} \Omega^{-2} + c{_1} M{_{20}} \mu{_{01}} \Omega^{-2} + c{_1} \mu{_{01}} \Omega^{-2} \mu{_{10}}^{2} + 2 c{_1} M{_{02}} \mu{_{10}} \Omega^{-2} + 2 c{_1} M{_{11}} \mu{_{01}} \Omega^{-2} + 2 c{_1} M{_{11}} \mu{_{10}} \Omega^{-2} - c{_1} M{_{11}} \Omega^{-2} - 2 c{_1} M{_{22}} \Omega^{-2} - 2 c{_1} M{_{02}} \Omega^{-2} \mu{_{10}}^{2} - 4 c{_1} M{_{12}} \mu{_{10}} \Omega^{-2} - 2 c{_1} M{_{21}} \mu{_{01}} \Omega^{-2} - c{_1} \mu{_{01}} \mu{_{10}} \Omega^{-2} - 4 c{_1} M{_{11}} \mu{_{01}} \mu{_{10}} \Omega^{-2}
\end{align*}\]</p><p>Unfortunately, central moment equations often take a visually painful form. Note that the first two ODEs, as before, indicate the means, and the central moments are denoted as</p><p class="math-container">\[M_{ij}(t) = \langle (X(t)-\mu_{10}(t))^i (Y(t)-\mu_{01}(t))^j \rangle.\]</p><h2 id="Applying-Moment-Closure"><a class="docs-heading-anchor" href="#Applying-Moment-Closure">Applying Moment Closure</a><a id="Applying-Moment-Closure-1"></a><a class="docs-heading-anchor-permalink" href="#Applying-Moment-Closure" title="Permalink"></a></h2><p>As observed above, the moment equations of the Brusselator are coupled and depend on higher order moments—we have an infinite hierarchy of ODEs in our hands which cannot be solved directly and requires approximate treatment. One way of approaching the problem is to apply moment closure approximations (MAs), in which higher order moments are expressed as functions of lower order moments, thus effectively truncating the hierarchy and enabling a numerical solution. A variety of MAs have been proposed in literature and are implemented in MomentClosure.jl, see the <strong>Theory</strong> <a href="../../theory/moment_closure_approximations/#moment_closure_approximations">section on MAs</a> for more details.</p><p>Let&#39;s apply <a href="../../theory/moment_closure_approximations/#normal_closure">normal closure</a> to the raw moment equations <code>raw_eqs</code> we have generated earlier using <a href="../../api/momentclosure_api/#MomentClosure.moment_closure"><code>moment_closure</code></a> function:</p><pre><code class="language-julia hljs">closed_raw_eqs = moment_closure(raw_eqs, &quot;normal&quot;)</code></pre><p>The function returns <a href="../../api/momentclosure_api/#MomentClosure.ClosedMomentEquations"><code>ClosedMomentEquations</code></a> that consists of both the <a href="https://mtk.sciml.ai/stable/systems/ODESystem/"><code>ModelingToolkit.ODESystem</code></a> containing all closed moment equations as well as the specific closure functions for each higher order raw moments. We can use Latexify again to look at the closed ODEs:</p><pre><code class="language-julia hljs">latexify(closed_raw_eqs)</code></pre><p class="math-container">\[\begin{align*}
\frac{d\mu{_{10}}}{dt} =&amp; c{_3} \Omega + c{_1} \mu{_{01}} \mu{_{20}} \Omega^{-2} + 2 c{_1} \mu{_{10}} \mu{_{11}} \Omega^{-2} - c{_2} \mu{_{10}} - c{_4} \mu{_{10}} - c{_1} \mu{_{11}} \Omega^{-2} - 2 c{_1} \mu{_{01}} \Omega^{-2} \mu{_{10}}^{2} \\
\frac{d\mu{_{01}}}{dt} =&amp; c{_2} \mu{_{10}} + c{_1} \mu{_{11}} \Omega^{-2} + 2 c{_1} \mu{_{01}} \Omega^{-2} \mu{_{10}}^{2} - c{_1} \mu{_{01}} \mu{_{20}} \Omega^{-2} - 2 c{_1} \mu{_{10}} \mu{_{11}} \Omega^{-2} \\
\frac{d\mu{_{20}}}{dt} =&amp; c{_2} \mu{_{10}} + c{_3} \Omega + c{_4} \mu{_{10}} + 2 c{_3} \Omega \mu{_{10}} + 2 c{_1} \mu{_{01}} \Omega^{-2} \mu{_{10}}^{2} + 6 c{_1} \mu{_{11}} \mu{_{20}} \Omega^{-2} - 2 c{_2} \mu{_{20}} - 2 c{_4} \mu{_{20}} - c{_1} \mu{_{11}} \Omega^{-2} - c{_1} \mu{_{01}} \mu{_{20}} \Omega^{-2} - 4 c{_1} \mu{_{01}} \Omega^{-2} \mu{_{10}}^{3} - 2 c{_1} \mu{_{10}} \mu{_{11}} \Omega^{-2} \\
\frac{d\mu{_{11}}}{dt} =&amp; c{_2} \mu{_{20}} + c{_1} \mu{_{11}} \Omega^{-2} + c{_3} \Omega \mu{_{01}} + c{_1} \mu{_{02}} \mu{_{20}} \Omega^{-2} + 2 c{_1} \Omega^{-2} \mu{_{11}}^{2} + 2 c{_1} \mu{_{01}} \Omega^{-2} \mu{_{10}}^{3} + 2 c{_1} \mu{_{10}} \Omega^{-2} \mu{_{01}}^{2} - c{_2} \mu{_{10}} - c{_2} \mu{_{11}} - c{_4} \mu{_{11}} - 2 c{_1} \mu{_{01}} \mu{_{11}} \Omega^{-2} - c{_1} \mu{_{02}} \mu{_{10}} \Omega^{-2} - 3 c{_1} \mu{_{11}} \mu{_{20}} \Omega^{-2} - 2 c{_1} \Omega^{-2} \mu{_{01}}^{2} \mu{_{10}}^{2} \\
\frac{d\mu{_{02}}}{dt} =&amp; c{_2} \mu{_{10}} + 2 c{_2} \mu{_{11}} + c{_1} \mu{_{01}} \mu{_{20}} \Omega^{-2} + 4 c{_1} \mu{_{01}} \mu{_{11}} \Omega^{-2} + 2 c{_1} \mu{_{02}} \mu{_{10}} \Omega^{-2} + 2 c{_1} \mu{_{10}} \mu{_{11}} \Omega^{-2} + 4 c{_1} \Omega^{-2} \mu{_{01}}^{2} \mu{_{10}}^{2} - c{_1} \mu{_{11}} \Omega^{-2} - 4 c{_1} \Omega^{-2} \mu{_{11}}^{2} - 2 c{_1} \mu{_{01}} \Omega^{-2} \mu{_{10}}^{2} - 2 c{_1} \mu{_{02}} \mu{_{20}} \Omega^{-2} - 4 c{_1} \mu{_{10}} \Omega^{-2} \mu{_{01}}^{2}
\end{align*}\]</p><p>The closure functions can also be displayed by adding <code>:closure</code> argument:</p><pre><code class="language-julia hljs">latexify(closed_raw_eqs, :closure)</code></pre><p class="math-container">\[\begin{align*}
\mu{_{21}} =&amp; \mu{_{01}} \mu{_{20}} + 2 \mu{_{10}} \mu{_{11}} - 2 \mu{_{01}} \mu{_{10}}^{2} \\
\mu{_{12}} =&amp; \mu{_{02}} \mu{_{10}} + 2 \mu{_{01}} \mu{_{11}} - 2 \mu{_{10}} \mu{_{01}}^{2} \\
\mu{_{31}} =&amp; \mu{_{01}} \mu{_{30}} + 6 \mu{_{01}} \mu{_{10}}^{3} + 3 \mu{_{10}} \mu{_{21}} + 3 \mu{_{11}} \mu{_{20}} - 6 \mu{_{11}} \mu{_{10}}^{2} - 6 \mu{_{01}} \mu{_{10}} \mu{_{20}} \\
\mu{_{22}} =&amp; \mu{_{02}} \mu{_{20}} + 2 \mu{_{11}}^{2} + 2 \mu{_{01}} \mu{_{21}} + 2 \mu{_{10}} \mu{_{12}} + 6 \mu{_{01}}^{2} \mu{_{10}}^{2} - 2 \mu{_{02}} \mu{_{10}}^{2} - 2 \mu{_{20}} \mu{_{01}}^{2} - 8 \mu{_{01}} \mu{_{10}} \mu{_{11}}
\end{align*}\]</p><p>Similarly, we can close central moment equations using</p><pre><code class="language-julia hljs">closed_central_eqs = moment_closure(central_eqs, &quot;normal&quot;)</code></pre><p>and print out the corresponding closure functions:</p><pre><code class="language-julia hljs">latexify(closed_central_eqs, :closure)</code></pre><p class="math-container">\[\begin{align*}
M{_{30}} =&amp; 0 \\
M{_{21}} =&amp; 0 \\
M{_{12}} =&amp; 0 \\
M{_{31}} =&amp; 3 M{_{11}} M{_{20}} \\
M{_{22}} =&amp; M{_{02}} M{_{20}} + 2 M{_{11}}^{2}
\end{align*}\]</p><p>Higher order central moments under normal closure take a rather simple form compared to their raw moment equivalents. That can be expected due to the relationship between central moments and cumulants, on which <a href="../../theory/moment_closure_approximations/#normal_closure">the closure is based</a>.</p><h2 id="Solving-Moment-Equations"><a class="docs-heading-anchor" href="#Solving-Moment-Equations">Solving Moment Equations</a><a id="Solving-Moment-Equations-1"></a><a class="docs-heading-anchor-permalink" href="#Solving-Moment-Equations" title="Permalink"></a></h2><p>The closed moment equations can be solved numerically using <a href="https://github.com/SciML/DifferentialEquations.jl/">DifferentialEquations.jl</a> that provides a variety of highly-efficient solvers and analysis tools. In order to do so, first we need to specify the values of all system parameters, the initial condition and the timespan to solve over. Then the <a href="https://mtk.sciml.ai/stable/systems/ODESystem/"><code>ModelingToolkit.ODESystem</code></a> corresponding to the moment equations can be <a href="https://mtk.sciml.ai/stable/#Compatible-Numerical-Solvers-1">directly converted</a> into an <code>ODEProblem</code> which can finally be solved. Let&#39;s go through the procedure step-by-step for the closed raw moment equations (<code>closed_raw_eqs</code>). Most of what is covered below is closely based on <a href="https://catalyst.sciml.ai/stable/tutorials/using_catalyst/#Mass-Action-ODE-Models">this Catalyst tutorial</a>.</p><p>We start with the parameters. Note that they are ordered as they appear after the <code>end</code> statement in the <code>@reaction_network</code> macro and this ordering can also be checked using the <code>paramsmap</code> function:</p><pre><code class="language-julia hljs">paramsmap(rn)</code></pre><pre><code class="language-julia hljs">Dict{Sym{ModelingToolkit.Parameter{Real}},Int64} with 5 entries:
  c₃ =&gt; 3
  Ω  =&gt; 5
  c₄ =&gt; 4
  c₂ =&gt; 2
  c₁ =&gt; 1</code></pre><p>We can now create a vector of parameter values as:</p><pre><code class="language-julia hljs"># parameters [c₁, c₂, c₃, c₄, Ω]
p = [0.9, 2, 1, 1, 100]</code></pre><p>Next, we can specify the initial condition. Usually when working with moment equations we consider <em>deterministic</em> initial conditions so that the molecule numbers at initial time take the specified integer values with probability one. We can define the initial molecule numbers as <span>$X(t=0) = X_0$</span> and <span>$Y(t=0) = Y_0$</span>. Probability one implies that initially the means will be equal to the molecule numbers, i.e., <span>$μ_{10}(t=0) = X_0$</span> and <span>$μ_{01}(t=0) = Y_0$</span>, whereas all higher order raw moments will be products of the corresponding powers of the means, e.g., <span>$μ_{21} = X_0^2 Y_0$</span>. Note that all central moments would be set to zero in this case. To make life easier we use <a href="../../api/momentclosure_api/#MomentClosure.deterministic_IC"><code>deterministic_IC</code></a> function which, given the initial molecule numbers, automatically constructs the variable mapping under deterministic initial conditions:</p><pre><code class="language-julia hljs"># initial molecule numbers [X, Y] (order as in speciesmap(rn))
u₀ = [1, 1]
u₀map = deterministic_IC(u₀, closed_raw_eqs)</code></pre><p>The next ingredient, the time interval to solve on, can be specified simply as:</p><pre><code class="language-julia hljs">tspan = (0., 100.)</code></pre><p>Now we are able to create the corresponding <code>ODEProblem</code>:</p><pre><code class="language-julia hljs">oprob = ODEProblem(closed_raw_eqs, u₀map, tspan, p)</code></pre><p>Finally, we have everything we need to solve the raw moment equations which can be done using any ODE solver <a href="https://diffeq.sciml.ai/dev/solvers/ode_solve/">implemented within DifferentialEquations.jl</a>. We use the default <code>Tsit5()</code> solver and then <a href="https://diffeq.sciml.ai/stable/basics/plot/#plot">plot</a> the obtained mean molecule numbers:</p><pre><code class="language-julia hljs"># using only ODE solvers from DifferentialEquations (faster to load)
using OrdinaryDiffEq
sol = solve(oprob, Tsit5(), saveat=0.1)

using Plots
plot(sol, vars=(0, [1,2]), lw=2)</code></pre><p><img src="../../assets/brusselator_means_1.svg" alt="Brusselator means 1"/></p><p>The obtained moment dynamics show damped oscillations which is the expected averaged behaviour of the Brusselator in a vast swathe of parameter space [1]. However, to establish more clearly how well a second order moment expansion with normal moment closure performs for this system and this specific set of parameters, we can compare the resulting moment trajectories to the true moment estimates obtained using <a href="https://en.wikipedia.org/wiki/Gillespie_algorithm">Gillespie&#39;s Stochastic Simulation Algorithm (SSA)</a>.</p><h2 id="Stochastic-Simulation"><a class="docs-heading-anchor" href="#Stochastic-Simulation">Stochastic Simulation</a><a id="Stochastic-Simulation-1"></a><a class="docs-heading-anchor-permalink" href="#Stochastic-Simulation" title="Permalink"></a></h2><p>To run the SSA for a given reaction network, we build a <a href="https://github.com/SciML/DiffEqJump.jl">DiffEqJump</a> <a href="https://diffeq.sciml.ai/latest/types/jump_types/"><code>JumpProblem</code></a> using Gillespie&#39;s <code>Direct</code> method (other SSA variants are also available, see the <a href="https://diffeq.sciml.ai/dev/types/jump_types/#Constant-Rate-Jump-Aggregators">documentation</a>). Moreover, in order to run many realisations of the jump process, we define a corresponding <a href="https://diffeq.sciml.ai/stable/features/ensemble/#ensemble"><code>EnsembleProblem</code></a>. All of this can be done as follows:</p><pre><code class="language-julia hljs">using DiffEqJump

# convert ReactionSystem into JumpSystem
jsys = convert(JumpSystem, rn, combinatoric_ratelaws=false)

# create a DiscreteProblem encoding that the molecule numbers are integer-valued
dprob = DiscreteProblem(jsys, u₀, tspan, p) # same parameters as defined earlier

# create a JumpProblem: specify Gillespie&#39;s Direct Method as the solver
# and SET save_positions to (false, false) as otherwise time of each
# reaction occurence would be saved (complicating moment estimates)
jprob = JumpProblem(jsys, dprob, Direct(), save_positions=(false, false))

# define an EnsembleProblem to simulate multiple trajectories
ensembleprob  = EnsembleProblem(jprob)

# simulate 10000 SSA trajectories
@time sol_SSA = solve(ensembleprob, SSAStepper(), saveat=0.1, trajectories=10000)</code></pre><p>Now we use the DifferentialEquations <a href="https://diffeq.sciml.ai/stable/features/ensemble/#Analyzing-an-Ensemble-Experiment">ensemble statistics tools</a> to calculate the SSA mean values and plot them:</p><pre><code class="language-julia hljs">using DiffEqBase.EnsembleAnalysis

means_SSA = timeseries_steps_mean(sol_SSA)
plot!(means_SSA, lw=2, labels=[&quot;SSA μ₁₀(t)&quot; &quot;SSA μ₀₁(t)&quot;], linestyle=:dash,
      linecolor=[1 2], background_color_legend=nothing, legend=:bottomright)</code></pre><p><img src="../../assets/brusselator_ssa_1.svg" alt="Brusselator SSA 1"/></p><p>The comparison to the SSA reveals that the second-order moment expansion using normal closure captures the correct qualitative behaviour of the Brusselator and provides reasonably accurate moment estimates given this particular parameter set. Note, however, that moment closure approximations can lead to unphysical results and suffer from numerical instabilities, please see the <a href="../common_issues/">Common Issues tutorial</a> for more details.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../../theory/linear_mapping_approximation/">« Linear Mapping Approximation</a><a class="docs-footer-nextpage" href="../using_momentclosure_SDE/">Moment Equations from SDEs »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.19 on <span class="colophon-date" title="Friday 17 June 2022 02:33">Friday 17 June 2022</span>. Using Julia version 1.7.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
